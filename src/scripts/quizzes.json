[{
  "_id": {
    "$oid": "65994f653cd5ace93a89177b"
  },
  "id": "contains-duplicate",
  "name": "Contains Duplicate",
  "video": "3OamzN90kPg",
  "free": true,
  "pattern": "Arrays & Hashing",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.\n\n \n\n**Example 1:**\n\n```markdown\nInput: nums = [1,2,3,1]\nOutput: true\n```\n\n**Example 2:**\n\n```markdown\nInput: nums = [1,2,3,4]\nOutput: false\n```\n \n\n**Constraints:**\n\n- `1 <= nums.length <= 10^5`\n- `10^9 <= nums[i] <= 10^9`\n",
  "questions": [
    {
      "questionPrompt": "How many possible pairs of elements are there in an array of size n?",
      "choices": [
        {
          "choice": "log n"
        },
        {
          "choice": "n"
        },
        {
          "choice": "n^2"
        },
        {
          "choice": "2^n"
        }
      ],
      "answerIndex": 2,
      "explanation": "There are exactly n * (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2, and we normally consider the largest term, which in this case is n^2."
    },
    {
      "questionPrompt": "What is the time complexity of a brute force approach, where you compare every possible pair in the array to check if there are any duplicates?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n * log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 2,
      "explanation": "The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements."
    },
    {
      "questionPrompt": "What data structure can you use to optimize the approach for checking if there are any duplicate elements in the array?",
      "choices": [
        {
          "choice": "Queue"
        },
        {
          "choice": "Priority Queue"
        },
        {
          "choice": "Stack"
        },
        {
          "choice": "Hashmap or HashSet"
        }
      ],
      "answerIndex": 3,
      "explanation": "A Hashmap (or Hashtable) and a HashSet allow us to store and retrieve values in constant time, O(1). We can utilize this property to efficiently check for duplicates."
    },
    {
      "questionPrompt": "How can a HashSet be used to efficiently check for duplicates in the array?",
      "choices": [
        {
          "choice": "Iterate through each element in the array and try to insert it into the HashSet. If an insertion fails (the element already exists in the HashSet), return true to indicate a duplicate was found."
        },
        {
          "choice": "Insert all elements from the array into the HashSet without checking for duplicates during this process. After all insertions, compare the size of the HashSet with the size of the array. If the HashSet size is smaller, return true to indicate a duplicate exists."
        },
        {
          "choice": "Both A and B"
        }
      ],
      "answerIndex": 2,
      "explanation": "A HashSet does not allow duplicate values. So, if you try to insert an element that already exists in the HashSet, it will not add the element and you know you've found a duplicate (choice A). Alternatively, you could add all elements to the HashSet and then compare its size to the size of the array. If the sizes are different, then there must have been a duplicate in the array (choice B). Both these methods will help identify if a duplicate exists in the array."
    },
    {
      "questionPrompt": "What is the time and space complexity of the solution using a hashmap?",
      "choices": [
        {
          "choice": "Time complexity: O(n)\nSpace complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n * log n)\nSpace complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2)\nSpace complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n)\nSpace complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap."
    }
  ],
  "similarQuestions": [
    "two-sum",
    "valid-anagram"
  ],
  "totalRatings": {
    "dislikes": 19,
    "likes": 2129
  },
  "totalSubmissions": 18928
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89177c"
  },
  "id": "valid-anagram",
  "name": "Valid Anagram",
  "video": "9UtInBqnCgA",
  "free": true,
  "pattern": "Arrays & Hashing",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven two strings `s` and `t`, return `true` *if `t` is an anagram of `s`, and `false` otherwise*.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n \n\n**Example 1:**\n```markdown\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n```\n\n\n**Example 2:**\n```\nInput: s = \"rat\", t = \"car\"\nOutput: false\n```\n\n**Constraints:**\n\n- `1 <= s.length, t.length <= 5 * 10^4`\n- `s` and `t` consist of lowercase English letters.\n",
  "questions": [
    {
      "questionPrompt": "What is the primary characteristic of an anagram?",
      "choices": [
        {
          "choice": "Both words have the same length."
        },
        {
          "choice": "Both words have the same letters, in the same quantities."
        },
        {
          "choice": "Both words have the same first letter."
        },
        {
          "choice": "Both words have the same last letter."
        }
      ],
      "answerIndex": 1,
      "explanation": "An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. This means both words have the same letters, in the same quantities. For example, 'Heart' is an anagram of 'Earth'."
    },
    {
      "questionPrompt": "Given the nature of anagrams, which of the following methods can be used to check if two words are anagrams?",
      "choices": [
        {
          "choice": "Compare the lengths of two words. If they are equal, the words are anagrams."
        },
        {
          "choice": "Convert each word to an array, sort the arrays, and then compare them."
        },
        {
          "choice": "Check if the first letter of the first word is present in the second word."
        }
      ],
      "answerIndex": 1,
      "explanation": "By converting each word to an array, sorting the arrays, and then comparing them, we can confirm if two words are anagrams. This is because anagrams have the same letters in the same quantities. For example, after sorting either 'heart' and 'earth', the result is 'aehrt'."
    },
    {
      "questionPrompt": "What is the time complexity of the solution that sorts and then compares the arrays? Note: We are using an efficient sorting algorithm where we can't make any assumptions about the character set.",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity of sorting an array of n elements is O(n log n), and the time complexity of comparing two arrays is O(n). When considering the largest term, the time complexity of the solution becomes O(n log n)."
    },
    {
      "questionPrompt": "Given the nature of anagrams and the constraints of the problem, can you improve upon the overall time complexity of the sorting solution?",
      "choices": [
        {
          "choice": "No, sorting and comparing is the most optimal solution."
        },
        {
          "choice": "Yes, by using a hashmap to store the count of letters."
        },
        {
          "choice": "Yes, by checking if the first and last letter of both words are the same."
        }
      ],
      "answerIndex": 1,
      "explanation": "Given the constraints of the problem and the nature of anagrams, we can use a hashmap to store the count of letters for each string. This would allow us to compare the frequency of each letter in both strings in a more time-efficient way. The downside is we may need extra memory, compared to an in-place sorting algorithm."
    },
    {
      "questionPrompt": "If using a hashmap to check if two words are anagrams, what would be the keys and the values in the hashmap?",
      "choices": [
        {
          "choice": "Keys = Words, Values = Count of each word"
        },
        {
          "choice": "Keys = Letters, Values = Count of each letter"
        },
        {
          "choice": "Keys = Length of words, Values = Words of that length"
        }
      ],
      "answerIndex": 1,
      "explanation": "In this case, the keys would be the letters, and the values would be the count of each letter. This way, we can track the frequency of each letter in the strings and compare them."
    },
    {
      "questionPrompt": "What is the time and space complexity of the solution using a hashmap to count and compare the frequency of each letter?",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity of this solution is O(n) because we iterate over the input strings once. The space complexity is also O(n) because in the worst-case scenario (where each letter is unique), we would need to store each letter in the hashmap."
    }
  ],
  "totalRatings": {
    "dislikes": 7,
    "likes": 1275
  },
  "totalSubmissions": 9629
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89177d"
  },
  "id": "two-sum",
  "name": "Two Sum",
  "video": "KLlXCFG5TnA",
  "free": true,
  "pattern": "Arrays & Hashing",
  "difficulty": "Easy",
  "leetcodePrompt": "Given an array of integers `nums` and an integer `target`, *return indices of the two numbers such that they add up to `target`*.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n  \n\nExample 1:\n\n```markdown\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n```",
  "questions": [
    {
      "questionPrompt": "Roughly how many pairs of integers are there within the array? Assume the size of the array is `n`.",
      "choices": [
        {
          "choice": "log n"
        },
        {
          "choice": "n"
        },
        {
          "choice": "n^2"
        },
        {
          "choice": "2^n"
        }
      ],
      "answerIndex": 2,
      "explanation": "There are exactly n * (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2 and we normally care about the largest term, which in this case is n^2."
    },
    {
      "questionPrompt": "How can you find all pairs of elements `x1, x2` within an array, which have a different index?",
      "choices": [
        {
          "choice": "Sorting the array and using binary search to find a pair"
        },
        {
          "choice": "Using two nested loops to iterate over all pairs of elements"
        },
        {
          "choice": "Using divide and conquer to recursively find pairs"
        }
      ],
      "answerIndex": 1,
      "explanation": "To find all pairs of elements with different indices in the array, you can use two nested loops. The first loop iterates over each element, while the second loop only iterates over the elements to the right of the current element. This allows you to compare all possible pairs without duplicates."
    },
    {
      "questionPrompt": "After finding each pair of elements, we can then easily determine the indices of the elements that sum to the target. What is the time complexity of this brute-force solution?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n * log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 2,
      "explanation": "The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements."
    },
    {
      "questionPrompt": "For any given element `x` within the array, how many possible unique `y-values` would satisfy `target = x + y`?",
      "choices": [
        {
          "choice": "1"
        },
        {
          "choice": "2"
        },
        {
          "choice": "n - 1"
        },
        {
          "choice": "n"
        }
      ],
      "answerIndex": 0,
      "explanation": "We can solve this equation for y: y = target - x. For example, if target=9, and x=2, then y = 9 - 2 = 7. In mathematics, this value is known as the complement."
    },
    {
      "questionPrompt": "Can you reduce the time complexity of the algorithm to find the indices of two numbers that add up to the target using a data structure?",
      "choices": [
        {
          "choice": "No, the time complexity cannot be reduced"
        },
        {
          "choice": "Yes, using a priority queue"
        },
        {
          "choice": "Yes, using a hashmap"
        },
        {
          "choice": "Yes, using a balanced binary search tree"
        }
      ],
      "answerIndex": 2,
      "explanation": "Yes, you can reduce the time complexity using a hashmap. A hashmap allows you to store and retrieve values in  O(1) - constant time, which can help you find the required indices more efficiently than a brute-force solution."
    },
    {
      "questionPrompt": "How can a hashmap be used to efficiently find the indices of two numbers that add up to the target in an array?",
      "choices": [
        {
          "choice": "Key = Index of each element, Value = Difference between the target and the corresponding element;\nthen for each element check if the difference between the target and the element exists as a value in the hashmap."
        },
        {
          "choice": "Key = Each element in the array, Value = The index of the corresponding element;\nthen for each element check if the difference exists in the hashmap as a key, and that it has a different index from the current element."
        }
      ],
      "answerIndex": 1,
      "explanation": "By storing each element in the array as a key and its index as the corresponding value in the hashmap, you can efficiently find the required pair. For each element, you can efficiently calculate the difference and check if it’s a key within the hashmap. If it does, we can get the index from the hashmap. If the index of the difference is different from the index of the current element (remember we are not allowed reuse the same element twice), then you've found the solution."
    },
    {
      "questionPrompt": "What is the time and space complexity of the optimal solution using a hashmap?",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n * log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap."
    }
  ],
  "totalRatings": {
    "dislikes": 17,
    "likes": 1397
  },
  "totalSubmissions": 9189
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89177f"
  },
  "id": "encode-and-decode-strings",
  "name": "Encode and Decode Strings",
  "video": "B1k_sxOSgv8",
  "free": true,
  "pattern": "Arrays & Hashing",
  "difficulty": "Medium",
  "leetcodePrompt": "\nDesign an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nPlease implement `encode` and `decode`\n\n**Example1**\n\n```\nInput: dummy_input = [\"Hello\", \"World\"]\nOutput: [\"Hello\", \"World\"]\nExplanation:\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nString[] strs = decoder.decode(msg);\n```\n\n**Example2**\n\n```\nInput: dummy_input = [\"\"]\nOutput: [\"\"]\n```\n\n**Constraints:**\n* `1 <= strs.length <= 200`\n* `0 <= strs[i].length <= 200`\n* `strs[i] contains any possible characters out of 256 valid ASCII characters`\n",
  "questions": [
    {
      "questionPrompt": "Given the constraint that `strs[i]` can contain any valid ASCII characters, including special ones, which encoding strategy should we use to ensure that our encoded message can be correctly decoded?",
      "choices": [
        {
          "choice": "Separate strings in strs using a special character, such as a comma or a space."
        },
        {
          "choice": "Use a length-prefix followed by a special character for each string in strs."
        },
        {
          "choice": "Concatenate all the strings in strs directly."
        }
      ],
      "answerIndex": 1,
      "explanation": "If we use a special character to separate the strings, it could be a problem if the string itself contains this special character. If we concatenate the strings directly, we can't distinguish where one string ends and another begins. Therefore, prefixing each string with its length followed by a special character allows us to correctly separate the strings during decoding, even if they contain special characters."
    },
    {
      "questionPrompt": "What should the prefix look like to make the encoding efficient?",
      "choices": [
        {
          "choice": "Prefix each string with the length of the entire list strs."
        },
        {
          "choice": "Prefix each string with its individual length followed by a delimiter."
        },
        {
          "choice": "Prefix each string with the sum of the lengths of all previous strings."
        }
      ],
      "answerIndex": 1,
      "explanation": "Prefixing each string with its own length allows us to know exactly where each string starts and ends in the encoded string, which simplifies the decoding process."
    },
    {
      "questionPrompt": "What should be the delimiter between the length prefix and the actual string content?",
      "choices": [
        {
          "choice": "The delimiter can be any character, as it is not important for decoding."
        },
        {
          "choice": "The delimiter should be a character that is not allowed in the strings."
        },
        {
          "choice": "The delimiter should be a non-integer character."
        }
      ],
      "answerIndex": 2,
      "explanation": "If the delimiter is a number, it could lead to confusion during decoding. Hence, we need to choose a delimiter that cannot be part of the prefix."
    },
    {
      "questionPrompt": "We can implement the encode and decode methods using `#` as the delimiter, as follow. What is the time and space complexity of the encode and decode methods? Assume `n` is the total length of the string.\n\n```python\nclass Codec:\n    def encode(self, strs: List[str]) -> str:\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n\n    def decode(self, s: str) -> List[str]:\n        res, i = [], 0\n        while i < len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n            length = int(s[i:j])\n            res.append(s[j + 1: j + 1 + length])\n            i = j + 1 + length\n        return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The overall time complexity of the solution is determined by the number of characters in the strings list (strs). We iterate over all characters twice: once when encoding and once when decoding. Therefore, the time complexity is linear. The space complexity is also linear because the encoded string has the same number of characters as the original strings list plus the length of each string and a colon for each string."
    }
  ],
  "totalRatings": {
    "dislikes": 10,
    "likes": 204
  },
  "totalSubmissions": 2750
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891780"
  },
  "id": "longest-consecutive-sequence",
  "name": "Longest Consecutive Sequence",
  "video": "P6RZZMu_maU",
  "free": true,
  "pattern": "Arrays & Hashing",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven an unsorted array of integers `nums`, return the *length of the longest consecutive elements sequence*.\n\nYou must write an algorithm that runs in `O(n)` time.\n\n \n\n**Example 1:**\n\n```\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n**Constraints:**\n\n- `0 <= nums.length <= 10^5`\n- `-10^9 <= nums[i] <= 10^9`\n",
  "questions": [
    {
      "questionPrompt": "For a given array of integers, what is the time complexity of finding the length of the longest consecutive sequence using sorting?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "Sorting an array generally takes O(n log n) time. Once the array is sorted, you could iterate through the array once to find the longest consecutive sequence, which would take O(n) time. However, the dominating factor is the sorting time complexity, thus the overall time complexity is O(n log n)."
    },
    {
      "questionPrompt": "Suppose we are counting the length of a sequence starting at an arbitrary value, say `n = 1.` To extend this sequence, we need to efficiently check for the existence of the next integer `(n + 1)`, regardless of its index in the original array. Which data structure would best serve this purpose?",
      "choices": [
        {
          "choice": "Priority Queue"
        },
        {
          "choice": "HashSet"
        },
        {
          "choice": "Binary Search Tree"
        },
        {
          "choice": "Array"
        }
      ],
      "answerIndex": 1,
      "explanation": "A HashSet can be used to efficiently check the existence of elements in O(1) average time complexity. When extending a sequence, this property is essential, allowing us to determine if the next integer (n + 1) exists in the original array, regardless of its position."
    },
    {
      "questionPrompt": "Consider the array `[1, 2, 3, 4, 5, 6]`. If we naively iterate through this array, treating each element `n` as the potential start of a sequence, we would check for the existence of each subsequent number `n + 1`. What would be the time complexity of such an approach?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 2,
      "explanation": "For every element in the array, except for 6, the follow-up element n + 1 does exist. So for each element, in the worst case, we would iterate n - 1 times to build each sequence, resulting in a time complexity of O(n^2)."
    },
    {
      "questionPrompt": "Consider the array `[100, 4, 200, 1, 3, 2]`. This array contains two sequences: `[1, 2, 3, 4]` and `[100, 200]`. What common trait do the starting elements `1` and `100` share, which suggests they are the beginning of these sequences?",
      "choices": [
        {
          "choice": "They are the smallest numbers in their respective sequences."
        },
        {
          "choice": "The element (n - 1) does not exist in the array."
        },
        {
          "choice": "The element (n + 1) does exist in the array."
        },
        {
          "choice": "They are the largest numbers in their respective sequences."
        }
      ],
      "answerIndex": 1,
      "explanation": "The key observation is that for any number 'n' to be the start of a sequence, the number (n - 1) must not exist in the array. This is because if (n-1) exists, 'n' would be part of a sequence starting at least from (n-1). In this case, for '1' and '100', neither '0' nor '99' exist in the array, indicating that '1' and '100' can indeed be the starting points of their sequences."
    },
    {
      "questionPrompt": "Knowing that an element 'n' is the start of a sequence if (n - 1) does not exist in the array, how could we efficiently solve this problem using a hashset?",
      "choices": [
        {
          "choice": "Add all elements to the hashset. Then, for each element 'n', if (n - 1) is not in the hashset, check and count the longest sequence starting from 'n'."
        },
        {
          "choice": "Add all elements to the hashset. Then, for each element 'n', if (n + 1) is in the hashset, check and count the longest sequence starting from 'n'."
        }
      ],
      "answerIndex": 0,
      "explanation": "We then iterate through each element 'n' and if (n - 1) is not in the hashset, we check for the longest sequence starting from 'n'. This is because if (n-1) does not exist, 'n' must be the starting point of a sequence. We then check for the existence of (n + 1), (n + 2), and so on in the hashset, and count the length of the sequence. This approach ensures that we don't repeatedly check the same sequence and keeps the time complexity to O(n)."
    },
    {
      "questionPrompt": "What is the time and space complexity of the optimal solution using a HashSet and avoiding unnecessary checks?",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The HashSet solution has a time complexity of O(n) because you need to iterate through the array twice (once for building the HashSet and once for checking the sequences). The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the HashSet."
    }
  ],
  "totalRatings": {
    "dislikes": 8,
    "likes": 302
  },
  "totalSubmissions": 3517
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891781"
  },
  "id": "valid-palindrome",
  "name": "Valid Palindrome",
  "video": "jJXJ16kPFWg",
  "free": true,
  "pattern": "Two Pointers",
  "difficulty": "Easy",
  "leetcodePrompt": "\nA phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.\n\n \n\n**Example 1:**\n\n```\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n```\n\n**Example 2:**\n\n```\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n```\n\n**Example 3:**\n\n```\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n ```\n\n**Constraints:**\n\n`1 <= s.length <= 2 * 10^5`\n`s consists only of printable ASCII characters.`\n",
  "questions": [
    {
      "questionPrompt": "Given a string, what is a crucial step in the initial preprocessing to determine whether it is a palindrome?",
      "choices": [
        {
          "choice": "Reverse the string."
        },
        {
          "choice": "Convert the string to lowercase."
        },
        {
          "choice": "Check if the string is empty."
        },
        {
          "choice": "Split the string into words."
        }
      ],
      "answerIndex": 1,
      "explanation": "A crucial step to check if a string is a palindrome is to convert it to lowercase. This is because palindromes are case-insensitive. However, it's important to note that removing non-alphanumeric characters is another critical preprocessing step not mentioned in this particular question."
    },
    {
      "questionPrompt": "After converting the string to lowercase, what should be the next step?",
      "choices": [
        {
          "choice": "Reverse the string."
        },
        {
          "choice": "Check if the string is empty."
        },
        {
          "choice": "Remove all non-alphanumeric characters."
        },
        {
          "choice": "Convert the string to uppercase."
        }
      ],
      "answerIndex": 2,
      "explanation": "The next step is to remove all non-alphanumeric characters. This is because palindromes only consider alphanumeric characters."
    },
    {
      "questionPrompt": "Once the string has been converted to lowercase and all non-alphanumeric characters have been removed, what is the final step to determine if it's a palindrome?",
      "choices": [
        {
          "choice": "Convert the string to uppercase."
        },
        {
          "choice": "Check if the string is equal to its reverse."
        },
        {
          "choice": "Check if the string is empty."
        },
        {
          "choice": "Split the string into words."
        }
      ],
      "answerIndex": 1,
      "explanation": "The final step to check if a string is a palindrome is to compare it to its reversed version. If they are the same, then the string is a palindrome."
    },
    {
      "questionPrompt": "What is the time and space complexity of the approach where we create a new reversed string to compare?",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity is O(n) because all operations (lowercase conversion, removing non-alphanumeric characters, and reversing the string) take linear time. The 'n' here is the length of the string. The space complexity is also O(n) because we are creating a new string for the reversed version, which can be as long as the input string."
    },
    {
      "questionPrompt": "Is there a way to check if a string is a palindrome without creating a new string for the reversed version?",
      "choices": [
        {
          "choice": "No, it's not possible."
        },
        {
          "choice": "Yes, by using two pointers."
        },
        {
          "choice": "Yes, by sorting the string."
        },
        {
          "choice": "Yes, by using a stack."
        }
      ],
      "answerIndex": 1,
      "explanation": "Yes, it is possible. You can use two pointers: one starting from the beginning of the string and the other from the end. If the characters at both pointers are equal, we increment the left pointer and decrement the right pointer. If they are not equal, then the string is not a palindrome. This approach avoids creating a new string for the reversed version, thus saving space."
    },
    {
      "questionPrompt": "What are the time and space complexities of the two-pointer approach to check if a string is a palindrome?",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 3,
      "explanation": "The time complexity is O(n) because in the worst case, we would have to compare every character in the string with its counterpart from the end. Here, 'n' is the length of the string. This is still linear time complexity. The space complexity is O(1) because no extra space proportional to the size of the input is used. The two pointers used do not scale with the input size."
    }
  ],
  "totalRatings": {
    "dislikes": 3,
    "likes": 325
  },
  "totalSubmissions": 3534
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891783"
  },
  "id": "3sum",
  "name": "3Sum",
  "video": "jzZsG8n2R9A",
  "free": true,
  "pattern": "Two Pointers",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n**Example 1:**\n\n```\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n```\n\n**Example 2:**\n\n```\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\n```\n\n**Example 3:**\n\n```\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n```\n\n**Constraints:**\n\n- `3 <= nums.length <= 3000`\n- `10^5 <= nums[i] <= 10^5`\n",
  "questions": [
    {
      "questionPrompt": "What is a brute-force approach to solving this problem and what is the time complexity of this approach?",
      "choices": [
        {
          "choice": "Iterate through all possible combinations of three elements, O(n^3) time complexity"
        },
        {
          "choice": "Iterate through all elements, creating pair sums in a hash table, O(n^2) time complexity"
        },
        {
          "choice": "Sort the array and apply binary search for each element, O(n^2 log n) time complexity"
        }
      ],
      "answerIndex": 0,
      "explanation": "The brute force approach would be to iterate through all possible triplets in the list and check if their sum is equal to zero. This would involve three nested loops and thus would have a time complexity of O(n^3)."
    },
    {
      "questionPrompt": "How can we find the optimal solution by using sorting?",
      "choices": [
        {
          "choice": "Sort the array and use two pointers, decreasing the time complexity to O(n^2)"
        },
        {
          "choice": "Sort the array and use binary search, decreasing the time complexity to O(n^2 log n)"
        },
        {
          "choice": "Sorting cannot help in optimizing this problem"
        }
      ],
      "answerIndex": 0,
      "explanation": "By sorting the array, we can iterate through the array once and then use a two-pointer approach for each iteration. The two pointers can move towards each other until they meet, checking if the sum of the elements at the pointers equals the negative of the current element. This reduces the time complexity to O(n^2). A binary search approach will also work, but is less efficient."
    },
    {
      "questionPrompt": "How can we ensure that our solution does not contain duplicate triplets?",
      "choices": [
        {
          "choice": "By checking if a triplet has already been added to a hash set"
        },
        {
          "choice": "By skipping over duplicate elements in the sorted array"
        },
        {
          "choice": "Both A and B"
        }
      ],
      "answerIndex": 2,
      "explanation": "Both methods can be used to avoid duplicate triplets. We can check if a triplet is already in our solution before adding it, or we can skip over duplicate elements in our sorted array, since any triplet containing these duplicates would have already been found."
    },
    {
      "questionPrompt": "How does the two-pointer approach help in eliminating duplicates in the output?",
      "choices": [
        {
          "choice": "It doesn't, duplicates must be handled separately"
        },
        {
          "choice": "By skipping over duplicate elements in the sorted array after finding a valid triplet, and also when choosing the first number in the triplet"
        },
        {
          "choice": "By checking if the current triplet is already in the output before adding it"
        }
      ],
      "answerIndex": 1,
      "explanation": "When we find a valid triplet, we increment the left pointer until we find a new value. This ensures that we do not add the same triplet multiple times when the array contains duplicates. Additionally, when choosing the first number for our triplet, if this number is the same as the previous number, we can skip it. This is because any valid triplets including this number would have already been found in the previous iteration. These steps effectively eliminate duplicate solutions in the final result set."
    },
    {
      "questionPrompt": "Given the optimized solution using sorting and a two-pointer approach, what is the overall time and space complexity?\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n        \n        for i, a in enumerate(nums):\n            if i > 0 and a == nums[i - 1]:\n                # We already used nums[i] as the \n                # first element, so skip it\n                continue\n\n            # Use two pointers on the remaining\n            # sorted subarray to solve a + b + c = 0\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    # Solution found\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        # Eliminate duplicates by incrementing \n                        # left ptr until new nums[l] is found\n                        l += 1\n        return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity is O(n^2) because we iterate through the array once (which is O(n)), and for each iteration, we potentially go through the rest of the array using the two-pointer approach (which is also O(n)), thus resulting in O(n^2). The space complexity is O(1) since we aren't using additional space, other than the output."
    }
  ],
  "totalRatings": {
    "dislikes": 6,
    "likes": 219
  },
  "totalSubmissions": 2694
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891784"
  },
  "id": "container-with-most-water",
  "name": "Container With Most Water",
  "video": "UuiTKBwPgAo",
  "free": true,
  "pattern": "Two Pointers",
  "difficulty": "Medium",
  "leetcodePrompt": "\nYou are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn *the maximum amount of water a container can store*.\n\n**Notice** that you may not slant the container.\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/abc2d8fd-6012-4f88-7674-f6302aaf4200/public)\n\n**Example 1:**\n\n```\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n```\n\n**Example 2:**\n\n```\nInput: height = [1,1]\nOutput: 1\n```\n\n**Constraints:**\n\n- `n == height.length`\n- `2 <= n <= 10^5`\n- `0 <= height[i] <= 10^4`\n",
  "questions": [
    {
      "questionPrompt": "The problem is about finding two lines that together with the x-axis form a container such that the container contains the most water. Which of the following is the key factor that determines the amount of water a container can hold?",
      "choices": [
        {
          "choice": "The height of the shortest line"
        },
        {
          "choice": "The height of the tallest line"
        },
        {
          "choice": "The distance between the two lines"
        },
        {
          "choice": "Both A and C"
        }
      ],
      "answerIndex": 3,
      "explanation": "The amount of water a container can hold is determined by the height of the shortest line (since water will overflow from the shorter line) and the distance between the two lines (since a wider container can hold more water)."
    },
    {
      "questionPrompt": "Consider a brute-force solution where you calculate the area for all possible pairs of lines. What would be the time complexity of such an approach?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 2,
      "explanation": "In a brute-force solution, you would have two nested loops to calculate the area for all pairs of lines. There are n*(n-1)/2 unique pairs, so the time complexity is O(n^2)."
    },
    {
      "questionPrompt": "When considering the parameters that affect the amount of water a container can hold, we know that the distance between the two lines is important. Given this, where should we initially place the two pointers in order to maximize the chance of finding the largest possible area?",
      "choices": [
        {
          "choice": "In the middle of the array"
        },
        {
          "choice": "At the shortest and tallest lines"
        },
        {
          "choice": "At the two ends of the array"
        },
        {
          "choice": "At random positions in the array"
        }
      ],
      "answerIndex": 2,
      "explanation": "To maximize the initial area, we should start with the widest possible container, by placing the two pointers at the two ends of the array. This allows us to be greedy and maximize the distance between the two lines. From there, we can move the pointers inward to explore other possible containers."
    },
    {
      "questionPrompt": "Given the array height = [1,8,6,2,5,4,8,3,7], we start with the widest container, i.e., the first and the last line. Why is it impossible for us to find a new maximum area by leaving the left pointer at index = 0, and shifting the right pointer inwards?",
      "choices": [
        {
          "choice": "Because the new container would be narrower but not taller."
        },
        {
          "choice": "Because the new container would be both narrower and taller."
        },
        {
          "choice": "Because the new container would be wider and not shorter."
        }
      ],
      "answerIndex": 0,
      "explanation": "The amount of water a container can hold is determined by the height of the shorter line. If we move the pointer at the taller line, the new container will be narrower (since the distance between the lines decreases), and it can't be taller (since the height is still limited by the shorter line). Therefore, there’s no need to consider anymore containers where the left pointer is at index = 0, since they will always be smaller than the current maximum."
    },
    {
      "questionPrompt": "The two-pointer technique ensures that we don't need to enumerate all n^2 combinations of pointers to find the maximal solution. How does the technique achieve this?",
      "choices": [
        {
          "choice": "By ensuring that every element in the array is guaranteed to have a pointer land on it at some point."
        },
        {
          "choice": "By skipping combinations that will never lead to a more maximal solution."
        },
        {
          "choice": "Both A and B."
        },
        {
          "choice": "None of the above."
        }
      ],
      "answerIndex": 2,
      "explanation": "The two-pointer technique starts with the widest possible container and moves the pointers inward, always choosing the pointer at the shorter line to move. This ensures that every element in the array is guaranteed to have a pointer land on it at some point. It also avoids unnecessary combinations by skipping those that won't lead to a larger area (i.e., those where the container would be narrower but not taller). This solution is based on a ‘proof by contradiction’. Since we are being greedy and only skipping combinations that won’t lead to a new maximum, we are guaranteed to find the solution."
    },
    {
      "questionPrompt": "What is the time and space complexity of the solution using the two-pointer technique?",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 3,
      "explanation": "The two-pointer solution has a time complexity of O(n) because you need to iterate through the array once. The space complexity is O(1) as we only use two pointers and a few variables to keep track of the maximum area, regardless of the size of the input array."
    }
  ],
  "totalRatings": {
    "dislikes": 3,
    "likes": 220
  },
  "totalSubmissions": 2530
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891785"
  },
  "id": "best-time-to-buy-and-sell-stock",
  "name": "Best Time to Buy and Sell Stock",
  "video": "1pkOgXD63yU",
  "free": true,
  "pattern": "Sliding Window",
  "difficulty": "Easy",
  "leetcodePrompt": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\n*Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.*\n\n \n\nExample 1:\n```\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n```",
  "questions": [
    {
      "questionPrompt": "What is the brute-force approach to solving this problem?",
      "choices": [
        {
          "choice": "Sorting the array and running binary search to find the difference between the minimum and maximum prices."
        },
        {
          "choice": "Calculating the profit for each valid pair of buying and selling days, and finding the maximum profit."
        },
        {
          "choice": "Sorting the array and finding the difference between the minimum and maximum prices."
        },
        {
          "choice": "Creating a new array with the differences between consecutive prices and finding the maximum difference."
        }
      ],
      "answerIndex": 1,
      "explanation": "The correct brute-force approach is to calculate the profit for each valid pair of buying and selling days, and then find the maximum profit. For each day, we calculate the profit for every other day in the future. We keep track of the maximum profit seen."
    },
    {
      "questionPrompt": "We can also solve this by iterating through the array once, while keeping track of just two values. What two values should we keep track of to maximize the profit?",
      "choices": [
        {
          "choice": "The maximum and minimum prices in the array."
        },
        {
          "choice": "The minimum price found so far and the maximum profit found so far."
        },
        {
          "choice": "The difference between each pair of prices and the maximum price found so far."
        },
        {
          "choice": "The maximum profit found so far and the index of the minimum price found so far."
        }
      ],
      "answerIndex": 1,
      "explanation": "We should keep track of the minimum price found so far and the maximum profit found so far. By keeping track of these two values, we can calculate the maximum potential profit at each step while iterating through the array."
    },
    {
      "questionPrompt": "How will we use the minimum price found so far and the maximum profit found so far to efficiently solve this problem?",
      "choices": [
        {
          "choice": "Using Kadane’s greedy algorithm."
        },
        {
          "choice": "Find the minimum price in the array, and for every other price compute the profit, until we find the maximum profit."
        },
        {
          "choice": "Iterate through the prices, if we find a new minimum price then update it. Compute the profit between the current price and the minimum price, if it exceeds the maximum profit, then update it."
        }
      ],
      "answerIndex": 2,
      "explanation": "We iterate through the prices, and for each price, if it is lower than the current minimum price, we update the minimum price. Then, we compute the profit by subtracting the current minimum from the current price. If this profit is greater than the current maximum profit, we update the maximum profit."
    },
    {
      "questionPrompt": "What is the time complexity of the optimal solution?",
      "choices": [
        {
          "choice": "O(1)"
        },
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The optimal solution has a time complexity of O(n), where n is the number of days (or the length of the input array). This is because we're iterating through the array just once."
    },
    {
      "questionPrompt": "What is the space complexity of the optimal solution?",
      "choices": [
        {
          "choice": "O(1)"
        },
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The optimal solution has a constant space complexity, O(1), as we are only keeping track of two variables (minimum price and maximum profit), regardless of the size of the input array."
    }
  ],
  "totalRatings": {
    "dislikes": 4,
    "likes": 337
  },
  "totalSubmissions": 3142
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891786"
  },
  "id": "longest-substring-without-repeating-characters",
  "name": "Longest Substring Without Repeating Characters",
  "video": "wiGpQwVHdE0",
  "free": true,
  "pattern": "Sliding Window",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven a string `s`, find the length of the **longest**\n\n**substring**\n\nwithout repeating characters.\n\n**Example 1:**\n\n```\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\n```\n\n**Example 2:**\n\n```\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\n```\n\n**Example 3:**\n\n```\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n```\n\n**Constraints:**\n\n- `0 <= s.length <= 5 * 104`\n- `s` consists of English letters, digits, symbols and spaces.\n",
  "questions": [
    {
      "questionPrompt": "What is a brute force solution to this problem?",
      "choices": [
        {
          "choice": "Check each character and its subsequent characters for equality."
        },
        {
          "choice": "Generate all possible substrings and check each for repeated characters."
        }
      ],
      "answerIndex": 1,
      "explanation": "The brute force solution for this problem would be to generate all possible substrings of the given string and check each of them for repeated characters. We would then keep track of the length of the longest substring without repeated characters."
    },
    {
      "questionPrompt": "As we build a substring, what kind of data structure can we use to keep track of the characters we have already seen?",
      "choices": [
        {
          "choice": "Stack"
        },
        {
          "choice": "Queue"
        },
        {
          "choice": "Hash Set"
        },
        {
          "choice": "Heap"
        }
      ],
      "answerIndex": 2,
      "explanation": "A Set is a data structure that maintains a collection of unique elements. It provides constant-time complexity for search, insertion, and deletion, making it a suitable choice for tracking unique characters in a string."
    },
    {
      "questionPrompt": "What approach can we use to solve this problem efficiently?",
      "choices": [
        {
          "choice": "Divide and Conquer"
        },
        {
          "choice": "Sliding Window"
        },
        {
          "choice": "Recursion"
        }
      ],
      "answerIndex": 1,
      "explanation": "The sliding window approach allows us to scan through the string once (linear time complexity) while keeping track of the longest substring without repeating characters. It's an optimal strategy for this problem as it avoids unnecessary repeated computations."
    },
    {
      "questionPrompt": "What can we do when we encounter a repeating character while expanding our window?",
      "choices": [
        {
          "choice": "Remove the repeating character from our data structure and continue expanding."
        },
        {
          "choice": "Shrink the window from the left until the repeating character is no longer in the window."
        },
        {
          "choice": "Discard the current window and start a new window from the next character."
        }
      ],
      "answerIndex": 1,
      "explanation": "When we encounter a repeating character, it means we need to shrink the window from the left until the repeating character is no longer in the window, as we are searching for substrings without repeating characters."
    },
    {
      "questionPrompt": "Considering the constraint that `s` consists of English letters, digits, symbols, and spaces, what is the maximum possible size of our window?",
      "choices": [
        {
          "choice": "26"
        },
        {
          "choice": "52"
        },
        {
          "choice": "95"
        }
      ],
      "answerIndex": 2,
      "explanation": "In ASCII, there are 95 printable characters: 26 lowercase English letters, 26 uppercase English letters, 10 digits (0-9), 32 special characters and symbols, and the space character. This makes a total of 95 unique characters. Even if you don’t know there are exactly 95, it reasonable that there would be more than 52 (26 uppercase, 26 lowercase)."
    },
    {
      "questionPrompt": "What is the time and space complexity of the sliding window approach for this problem? Assume `n` is the length of the string, and `m` is the number of distinct characters in the string.\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_set = set()\n        l, max_len = 0, 0\n        \n        for r in range(len(s)):\n            while s[r] in char_set:\n                # Repeating char detected, shrink window\n                char_set.remove(s[l])\n                l += 1\n            char_set.add(s[r])\n            max_len = max(max_len, r - l + 1)\n        return max_len\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(m)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(m)"
        }
      ],
      "answerIndex": 1,
      "explanation": "Using the sliding window approach, we essentially scan through the string once with two pointers, making the time complexity O(n). The space complexity is O(m) because, in the worst-case scenario, the set used to check for repeating characters can contain all the distinct characters in the string, where m is the number of distinct characters."
    }
  ],
  "totalRatings": {
    "dislikes": 0,
    "likes": 126
  },
  "totalSubmissions": 1831
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891787"
  },
  "id": "longest-repeating-character-replacement",
  "name": "Longest Repeating Character Replacement",
  "video": "gqXU1UyA8pk",
  "free": true,
  "pattern": "Sliding Window",
  "difficulty": "Medium",
  "leetcodePrompt": "\nYou are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn *the length of the longest substring containing the same letter you can get after performing the above operations*.\n\n**Example 1:**\n\n```\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n\n```\n\n**Example 2:**\n\n```\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achive this answer too.\n```\n\n**Constraints:**\n\n- `1 <= s.length <= 105`\n- `s` consists of only uppercase English letters.\n- `0 <= k <= s.length`\n",
  "questions": [
    {
      "questionPrompt": "What is a brute force solution to this problem?",
      "choices": [
        {
          "choice": "Iterate from the end of the string to the beginning, checking for duplicate characters."
        },
        {
          "choice": "For each substring, find the frequency of the most common character (maxf) and check if the length of the substring minus maxf is less than or equal to k."
        }
      ],
      "answerIndex": 1,
      "explanation": "The brute force solution would be to generate all possible substrings and for each substring, find the frequency of the most common character. If the length of the substring minus the frequency of the most common character is less than or equal to k, then the substring is valid (since we can change at most k characters to make all characters in the substring the same). We would then keep track of the maximum length of such valid substrings."
    },
    {
      "questionPrompt": "What kind of data structure could help us track the frequency of each character in the current window of our string?",
      "choices": [
        {
          "choice": "Queue"
        },
        {
          "choice": "Array"
        },
        {
          "choice": "Hash Map"
        },
        {
          "choice": "Either B or C"
        }
      ],
      "answerIndex": 3,
      "explanation": "Both an Array and a Hash Map can be used to efficiently count the frequency of elements. By keeping a frequency count of characters in our current window, we can determine the most frequent character.\n\nIn the case of an Array, we could use each index to represent a unique character from the string (i.e., 'A' to 'Z' mapped to 0 to 25). In the case of a Hash Map, we would use the character itself as the key and the frequency as the value. Both methods allow us to update and access the frequency of each character in constant time."
    },
    {
      "questionPrompt": "Considering an efficient approach, what strategy could we use to solve this problem efficiently?",
      "choices": [
        {
          "choice": "Divide and Conquer"
        },
        {
          "choice": "Two pointers with sliding window"
        },
        {
          "choice": "Recursion"
        }
      ],
      "answerIndex": 1,
      "explanation": "The two pointers with sliding window strategy allows us to scan through the string in linear time complexity while keeping track of the longest substring with the same letters. The sliding window size changes based on the character frequency and the number of operations allowed."
    },
    {
      "questionPrompt": "If our current window size minus the frequency of the most common character is greater than k, what should we do?",
      "choices": [
        {
          "choice": "Expand the window from the right"
        },
        {
          "choice": "Shrink the window from the left"
        },
        {
          "choice": "Increase k"
        },
        {
          "choice": "Change the character at the left of the window"
        }
      ],
      "answerIndex": 1,
      "explanation": "If the window size minus the frequency of the most common character is greater than k, it means we cannot make all characters the same in this window by changing k characters. Therefore, we need to shrink the window from the left."
    },
    {
      "questionPrompt": "Considering that the given string only contains uppercase English letters (from A to Z), what would be the time complexity of finding the most frequent character in the window?",
      "choices": [
        {
          "choice": "O(1)"
        },
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(logn)"
        }
      ],
      "answerIndex": 0,
      "explanation": "Since we know that the string only contains uppercase English letters, there can be at most 26 unique characters. Thus, if we were to iterate through each unique character in our frequency dictionary or array to find the most frequent one, the time complexity would be O(26), which is essentially constant time, O(1)."
    },
    {
      "questionPrompt": "What is the time and space complexity of the sliding window approach for this problem? Assume `n` is the length of the string.\n\n```python\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        res = 0\n        l = 0\n        count = [0] * 26\n        for r in range(len(s)):\n            count[ord(s[r]) - ord('A')] += 1\n            while (r - l + 1) - max(count) > k:\n                count[ord(s[l]) - ord('A')] -= 1\n                l += 1\n            res = max(res, r - l + 1)\n        return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The sliding window approach only scans the string once, and the time complexity is therefore O(n). The space complexity is O(1) because the count array always has a fixed size of 26, corresponding to the number of uppercase English letters. Even though we're dealing with a string of n characters, we're only ever tracking a maximum of 26 different ones."
    }
  ],
  "totalRatings": {
    "dislikes": 3,
    "likes": 95
  },
  "totalSubmissions": 1451
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891788"
  },
  "id": "minimum-window-substring",
  "name": "Minimum Window Substring",
  "video": "jSto0O4AJbM",
  "free": true,
  "pattern": "Sliding Window",
  "difficulty": "Hard",
  "leetcodePrompt": "\nGiven two strings `s` and `t` of lengths `m` and `n` respectively, return the ***minimum window substring*** of `s` such that every character in `t` (***including duplicates***) is included in the window. If there is no such substring, return the empty string `\"\"`.\n\nThe testcases will be generated such that the answer is **unique**.\n\n**Example 1:**\n\n```\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n```\n\n**Example 2:**\n\n```\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n\n```\n\n**Example 3:**\n\n```\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n```\n\n**Constraints:**\n\n- `m == s.length`\n- `n == t.length`\n- `1 <= m, n <= 10^5`\n- `s` and `t` consist of uppercase and lowercase English letters.\n",
  "questions": [
    {
      "questionPrompt": "What is a brute force solution for this problem?",
      "choices": [
        {
          "choice": "Check all substrings of s to find if they contain all characters of t"
        },
        {
          "choice": "Remove each character of s one by one and check if the remaining string contains t"
        },
        {
          "choice": "Sort both s and t and check if t is a substring of s"
        }
      ],
      "answerIndex": 0,
      "explanation": "The brute force solution would be to generate all possible substrings of s and for each substring, check if it contains all characters of t including duplicates. Then we keep the shortest such valid substring."
    },
    {
      "questionPrompt": "What kind of data structure could help us track the frequency of each character in the current window of our string?",
      "choices": [
        {
          "choice": "Linked List"
        },
        {
          "choice": "Hash Map"
        },
        {
          "choice": "Stack"
        }
      ],
      "answerIndex": 1,
      "explanation": "A Hash Map is a good data structure to efficiently track the frequency of each character in the current window. By using the character itself as the key and the frequency as the value, we can access and update the frequency of each character in constant time."
    },
    {
      "questionPrompt": "Considering an efficient approach, what strategy could we use to solve this problem?",
      "choices": [
        {
          "choice": "Divide and Conquer"
        },
        {
          "choice": "Two Pointers with Sliding Window"
        },
        {
          "choice": "Binary Search"
        }
      ],
      "answerIndex": 1,
      "explanation": "The Two Pointers with Sliding Window strategy allows us to scan through the string in linear time complexity while keeping track of the smallest valid substring. We maintain a sliding window that always satisfies the condition of containing all characters of `t`."
    },
    {
      "questionPrompt": "What should we do if our current window doesn't contain all characters of `t`?",
      "choices": [
        {
          "choice": "Expand the window from the right"
        },
        {
          "choice": "Shrink the window from the left"
        },
        {
          "choice": "Remove the window and create a new one"
        }
      ],
      "answerIndex": 0,
      "explanation": "If our current window does not contain all characters of `t`, it means we need to expand the window from the right in hope of including the missing characters."
    },
    {
      "questionPrompt": "If our current window contains all characters of `t`, what should we do to find the smallest valid window?",
      "choices": [
        {
          "choice": "Expand the window from the right"
        },
        {
          "choice": "Shrink the window from the left"
        },
        {
          "choice": "Expand the window from the left"
        }
      ],
      "answerIndex": 1,
      "explanation": "If our current window already contains all characters of `t`, we try to shrink the window from the left to find the smallest window that still satisfies the condition. If we can't shrink it without losing a necessary character, we move on to expanding it from the right again."
    },
    {
      "questionPrompt": "How can we determine if our current window contains all characters of `t` without iterating through the entire hashmap?",
      "choices": [
        {
          "choice": "By checking if the length of the window is greater than or equal to the length of `t`"
        },
        {
          "choice": "By keeping track of two variables: the number of unique characters we have from `t` in our current window and the total unique characters needed from `t`"
        },
        {
          "choice": "By sorting the hashmap and comparing it with `t`"
        }
      ],
      "answerIndex": 1,
      "explanation": "By maintaining two variables, `have` and `need`, we can efficiently check if our window contains all characters of `t`. `need` is the number of unique characters in `t`, and `have` is the number of unique characters in `t` that our window currently contains. Each time we add a character to our window that makes the count of that character match what's needed in `t`, we increment `have`. We know our window contains all characters of `t` when `have` equals `need`."
    },
    {
      "questionPrompt": "Given that the input strings only consist of lowercase or uppercase English characters, what is the time and space complexity of the sliding window approach below? Assume `n` is the length of `s` and `m` is the length of `t`.\n\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == '': return ''\n\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float('infinity')\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n\n            if c in countT and window[c] == countT[c]:\n                have += 1\n\n            while have == need:\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = (r - l + 1)\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l:r+1] if resLen != float('infinity') else ''\n```\n",
      "choices": [
        {
          "choice": "Time complexity: O(n+m), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(m)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity is O(n+m) as we go through both s and t once. The space complexity is O(1) because the countT and window dictionaries will at most contain 52 unique keys, corresponding to the 26 lowercase and 26 uppercase English letters, which is a constant number and does not grow with n or m."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 75
  },
  "totalSubmissions": 1194
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891789"
  },
  "id": "valid-parentheses",
  "name": "Valid Parentheses",
  "video": "WTzjTskDFMg",
  "free": true,
  "pattern": "Stack",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven a string s containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nEvery close bracket has a corresponding open bracket of the same type.\n \n\n**Example 1:**\n\n\n```\nInput: s = \"()[]{}\"\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: s = \"(]\"\nOutput: false\n ```\n\n**Constraints:**\n\n- `1 <= s.length <= 10^4`\n- `s` consists of parentheses only `'()[]{}'`\n",
  "questions": [
    {
      "questionPrompt": "Consider the string s = \"( [ ) ]\" . Is this string valid?",
      "choices": [
        {
          "choice": "Yes"
        },
        {
          "choice": "No"
        }
      ],
      "answerIndex": 1,
      "explanation": "Although every opening bracket has a matching closing bracket of the same type, they are not closed in the correct order. The first opening bracket is '(', but the first closing bracket after that is ']', which is not the correct matching closing bracket."
    },
    {
      "questionPrompt": "At any point in the string, we can only close the most recent open bracket, and after we close a bracket we then want to close the next most recent open bracket. Which data structure would be most useful here?",
      "choices": [
        {
          "choice": "Hashmap"
        },
        {
          "choice": "Stack"
        },
        {
          "choice": "Queue"
        },
        {
          "choice": "Binary Tree"
        }
      ],
      "answerIndex": 1,
      "explanation": "A Stack is a LIFO (Last In First Out) data structure, which aligns well with this problem's requirements. When dealing with nested structures, like brackets, the most recently opened bracket must be the first one to be closed. This 'last opened, first closed' pattern is a characteristic behavior of a Stack, making it a suitable data structure to handle such scenarios."
    },
    {
      "questionPrompt": "Assume we iterate through the string s and we maintain a stack. What should we do when we encounter an open bracket?",
      "choices": [
        {
          "choice": "Ignore it."
        },
        {
          "choice": "Check if it matches with the top element of the stack."
        },
        {
          "choice": "Push it onto the stack."
        },
        {
          "choice": "Pop the top element from the stack."
        }
      ],
      "answerIndex": 2,
      "explanation": "When we encounter an open bracket, we should push it onto the stack. The stack is used to keep track of the open brackets that we have encountered but not yet closed."
    },
    {
      "questionPrompt": "Assume we iterate through the string s and we maintain a stack. What should we do when we encounter a closing bracket?",
      "choices": [
        {
          "choice": "Ignore it."
        },
        {
          "choice": "Push it onto the stack."
        },
        {
          "choice": "Pop the top element from the stack and check if it matches with the current closing bracket."
        },
        {
          "choice": "Check if it matches with the bottom element of the stack."
        }
      ],
      "answerIndex": 2,
      "explanation": "When we encounter a closing bracket, we should pop the top element from the stack and check if it is the matching opening bracket for the current closing bracket. If it is, we can continue; if it's not, or if the stack is empty, then the string is not valid."
    },
    {
      "questionPrompt": "After reaching the end of s, how do we know if the string is valid?",
      "choices": [
        {
          "choice": "If the stack is empty."
        },
        {
          "choice": "If the stack is not empty."
        },
        {
          "choice": "If the last element in the stack is an open bracket."
        },
        {
          "choice": "If the last element in the stack is a closing bracket."
        }
      ],
      "answerIndex": 0,
      "explanation": "If we have managed to close all open brackets while iterating through the string, the stack should be empty at the end. If the stack is not empty, it means there are some open brackets that were not closed, so the string is not valid."
    },
    {
      "questionPrompt": "What is the time and space complexity of the solution using a stack? Assume the length of the input string is n.",
      "choices": [
        {
          "choice": "Time: O(n), Space: O(1)"
        },
        {
          "choice": "Time: O(n), Space: O(n)"
        },
        {
          "choice": "Time: O(n), Space: O(n^2)"
        },
        {
          "choice": "Time: O(n^2), Space: O(n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "We are iterating through the string only once, where n is the length of the string. For each character, we are performing a constant amount of work (either pushing onto the stack or popping from it). Hence, the time complexity is O(n).\nIn the worst-case scenario, all characters in the string are opening brackets, and we push all of them onto the stack. Hence, the space complexity is O(n), where n is the length of the string."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 228
  },
  "totalSubmissions": 2338
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89178c"
  },
  "id": "search-in-rotated-sorted-array",
  "name": "Search in Rotated Sorted Array",
  "video": "U8XENwh8Oy8",
  "free": true,
  "pattern": "Binary Search",
  "difficulty": "Medium",
  "leetcodePrompt": "\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\n\nPrior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.\n\nGiven the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n \n\n**Example 1:**\n```\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n```\n\n**Example 2:**\n```\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n```\n\n**Constraints:**\n\n- `1 <= nums.length <= 5000`\n- `-10^4 <= nums[i] <= 10^4`\n- `All values of nums are unique.`\n- `nums is an ascending array that is possibly rotated.`\n- `-10^4 <= target <= 10^4`\n",
  "questions": [
    {
      "questionPrompt": "Suppose we have a normal sorted integer array. What is normally the optimal time complexity to find an element in it?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(1)"
        }
      ],
      "answerIndex": 1,
      "explanation": "For a sorted array, binary search can be applied to find an element. The time complexity of binary search is O(log n)."
    },
    {
      "questionPrompt": "Now consider a sorted array that has been rotated at an unknown index. What is the time complexity of the *simplest* (but non-optimal) solution to find an element in this array?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The simplest solution would be to perform a linear search, which has a time complexity of O(n)."
    },
    {
      "questionPrompt": "In a typical binary search, what is the first element we check to see if it's equal to the target?",
      "choices": [
        {
          "choice": "The first element in the array"
        },
        {
          "choice": "The last element in the array"
        },
        {
          "choice": "The middle element in the array"
        },
        {
          "choice": "The element at a random position in the array"
        }
      ],
      "answerIndex": 2,
      "explanation": "In a binary search, we first check the middle element of the array. If the target is equal to it, we're done. If the target is greater, we know our target must be in the right portion of the array, and if it's less, the target must be in the left portion."
    },
    {
      "questionPrompt": "As we search the rotated sorted array, how can we use the current middle element to determine which half of the array we are currently inside?",
      "choices": [
        {
          "choice": "Compare the middle element with nums[0]."
        },
        {
          "choice": "Compare the middle element with nums[length - 1]."
        },
        {
          "choice": "Compare the middle element with nums[mid - 1]."
        },
        {
          "choice": "Either A or B."
        }
      ],
      "answerIndex": 3,
      "explanation": "We can determine which half of the array we are currently inside by comparing the middle element with the first element (nums[0]) or the last element (nums[length - 1]). If the middle element is greater than or equal to nums[0], we are in the left portion of the array; otherwise, we are in the right sorted portion. Alternatively, if the middle element is less than or equal to nums[length - 1] we are in the right sorted portion, otherwise we are in the left portion."
    },
    {
      "questionPrompt": "How can we determine if the target element belongs to the left or right portion of the array?",
      "choices": [
        {
          "choice": "Compare the target with nums[mid]."
        },
        {
          "choice": "Compare the target with nums[0] or nums[length - 1]."
        },
        {
          "choice": "Compare the target with nums[mid - 1] and nums[mid + 1]."
        },
        {
          "choice": "None of the above."
        }
      ],
      "answerIndex": 1,
      "explanation": "We can determine if the target element belongs to the left or right portion of the array by comparing the target with the first element (nums[0]) or the last element (nums[length - 1]). If the target is greater than or equal to the first element, it belongs to the left portion of the array. If the target is less than the first element, it belongs to the right portion of the array."
    },
    {
      "questionPrompt": "If we are in the left sorted half of the array, but the target element belongs in the right sorted half, where should we search relative to the mid pointer?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/90bcf494-c8c6-4c8e-5119-349868839200/public)",
      "choices": [
        {
          "choice": "To the left of mid."
        },
        {
          "choice": "To the right of mid."
        },
        {
          "choice": "At the mid point."
        },
        {
          "choice": "This scenario is not possible."
        }
      ],
      "answerIndex": 1,
      "explanation": "If we are in the left sorted half of the array, but the target element belongs to the right sorted half, we should continue our search to the right of the mid pointer."
    },
    {
      "questionPrompt": "If we are in the right sorted half of the array, but the target element belongs in the left sorted half, where should we search relative to the mid pointer?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/37e384cf-75a6-4148-d389-0beb27f7ee00/public)",
      "choices": [
        {
          "choice": "To the left of mid."
        },
        {
          "choice": "To the right of mid."
        },
        {
          "choice": "At the mid point."
        },
        {
          "choice": "This scenario is not possible."
        }
      ],
      "answerIndex": 0,
      "explanation": "If we are in the right sorted half of the array, but the target element belongs to the left sorted half, we should continue our search to the left of the mid pointer."
    },
    {
      "questionPrompt": "If we are in the appropriate half of the array, can we simply perform a normal binary search?",
      "choices": [
        {
          "choice": "Yes"
        },
        {
          "choice": "No"
        }
      ],
      "answerIndex": 0,
      "explanation": "Yes, if we are in the appropriate half of the array, we can simply perform a normal binary search. The normal binary search process involves comparing the target with the middle element and then deciding whether to continue the search in the left portion or the right portion of the array, depending on whether the target is less or greater than the middle element."
    },
    {
      "questionPrompt": "\nTo summarize, the below code will solve this problem using an augmented binary search solution. What is the time and space complexity?\n```python\ndef search(self, nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] >= nums[0] and target < nums[0]:\n            # We're in left sorted array\n            # But target is in right sorted array \n            left = mid + 1\n        elif nums[mid] < nums[0] and target >= nums[0]:\n            # We're in right sorted array\n            # But target is in left sorted array \n            right = mid - 1\n        # Otherwise: Normal binary search\n        elif target > nums[mid]:\n            left = mid + 1\n        elif target < nums[mid]:\n            right = mid - 1\n        else:\n            return mid\n        \n        return -1\n```\n",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(log n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The binary search approach has a time complexity of O(log n) because in each step, you reduce the problem size by half. The space complexity is O(1) because you are not using any additional space that scales with the input size. You only need a constant amount of space to store the variables left, right, and mid."
    }
  ],
  "totalRatings": {
    "dislikes": 9,
    "likes": 105
  },
  "totalSubmissions": 1300
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89178d"
  },
  "id": "find-minimum-in-rotated-sorted-array",
  "name": "Find Minimum in Rotated Sorted Array",
  "video": "nIVW4P8b1VA",
  "free": true,
  "pattern": "Binary Search",
  "difficulty": "Medium",
  "leetcodePrompt": "\nSuppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:\n\n- `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.\n- `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.\n\nYou must write an algorithm that runs in `O(log n)` time.\n\n \n\n**Example 1:**\n\n```\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n```\n\n**Example 2:**\n\n```\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n```\n\n**Example 3:**\n\n```\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n``` \n\n**Constraints:**\n\n- `n == nums.length`\n- `1 <= n <= 5000`\n- `-5000 <= nums[i] <= 5000`\n- All the integers of `nums` are unique.\n- `nums` is sorted and rotated between `1` and `n` times.\n",
  "questions": [
    {
      "questionPrompt": "Suppose we have a *normal* sorted integer array. What is the time complexity to find the minimum element in this array?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(1)"
        }
      ],
      "answerIndex": 3,
      "explanation": "In a sorted array, the minimum element is always at the beginning, which can be found in constant time, O(1)."
    },
    {
      "questionPrompt": "Now consider a sorted array that has been rotated at an unknown index. What is the time complexity of the *simplest* (but non-optimal) solution to find the minimum element in this array?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The simplest solution would be to perform a linear search, which has a time complexity of O(n)."
    },
    {
      "questionPrompt": "In a typical binary search, what is the first element we check to see if it's the target?",
      "choices": [
        {
          "choice": "The first element in the array"
        },
        {
          "choice": "The last element in the array"
        },
        {
          "choice": "The middle element in the array"
        },
        {
          "choice": "The element at a random position in the array"
        }
      ],
      "answerIndex": 2,
      "explanation": "In a binary search, we first check the middle element of the array. Depending on the condition, we decide whether to proceed to the left half or the right half."
    },
    {
      "questionPrompt": "In this case, our target is the minimum element. Which portion of the array will it be found?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/02eaac7f-445e-4d1c-d51b-48c7c6aa2d00/public)",
      "choices": [
        {
          "choice": "The left sorted portion"
        },
        {
          "choice": "The right sorted portion"
        }
      ],
      "answerIndex": 1,
      "explanation": "The minimum element will be found in the right sorted portion since every element in that portion will be less than every element in the left sorted portion. The minimum element will be the leftmost value in the right sorted portion."
    },
    {
      "questionPrompt": "If the current portion of our search range from left to right is already sorted, e.g. `nums[l] < nums[r]`, then which element is the minimum of the current search range?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/958a3861-e7b7-4da8-8561-544714ca8400/public)",
      "choices": [
        {
          "choice": "nums[m]"
        },
        {
          "choice": "nums[l]"
        },
        {
          "choice": "nums[r]"
        },
        {
          "choice": "None of the above."
        }
      ],
      "answerIndex": 1,
      "explanation": "In a normal sorted array, the leftmost element is the minimum. In our case, if the original array is rotated n times, the minimum will be nums[0]. Alternatively, as we run binary search, if the current subarray of our search is a normal sorted array, we can end the binary search."
    },
    {
      "questionPrompt": "If the middle element is less than the first element of the array, where is the minimum element?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/33828cf2-4d4e-42d0-e429-b03e49111500/public)",
      "choices": [
        {
          "choice": "At the mid point."
        },
        {
          "choice": "At the mid point or to the left of mid."
        },
        {
          "choice": "To the right of mid."
        }
      ],
      "answerIndex": 1,
      "explanation": "If the middle element is less than the first element, it means the middle element is in the right sorted portion. The smallest element will always be found in the right sorted portion, so either the middle element is the minimum or the minimum is to the left of mid."
    },
    {
      "questionPrompt": "If the middle element is greater than or equal to the first element of the array, where is the minimum element?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c5da4e6e-997d-4ccc-952d-9dd0360f9200/public)",
      "choices": [
        {
          "choice": "To the left of mid."
        },
        {
          "choice": "To the right of mid."
        },
        {
          "choice": "At the mid point."
        },
        {
          "choice": "This scenario is not possible."
        }
      ],
      "answerIndex": 1,
      "explanation": "If the middle element is greater than the first element, it means the middle element is in the left sorted portion, but the minimum must be found in the right sorted portion."
    },
    {
      "questionPrompt": "To summarize, the below code will solve this problem using an augmented binary search solution. What is the time and space complexity?\n\n```python\ndef findMin(self, nums: List[int]) -> int:\n    res = nums[0]\n    l, r = 0, len(nums) - 1\n\n    while l <= r:\n        if nums[l] < nums[r]:\n            return min(res, nums[l])\n\n        m = (l + r) // 2\n        res = min(res, nums[m])\n        if nums[m] >= nums[l]:\n            # We are in the left sorted portion, move right\n            l = m + 1\n        else:\n            # We are in the right sorted portion, move left\n            r = m - 1\n    return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(log n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The binary search approach has a time complexity of O(log n) because in each step, you reduce the problem size by half. The space complexity is O(1) because you are not using any additional space that scales with the input size. You only need a constant amount of space to store the variables left, right, and mid."
    }
  ],
  "totalRatings": {
    "dislikes": 5,
    "likes": 80
  },
  "totalSubmissions": 1024
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89178f"
  },
  "id": "reverse-linked-list",
  "name": "Reverse Linked List",
  "video": "G0_I-ZF0S38",
  "free": true,
  "pattern": "Linked List",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven the `head` of a singly linked list, reverse the list, and return *the reversed list*.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/b57f05e4-bd0a-4d71-2066-bfad19f84300/public)\n\n```\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\n```\n\n**Example 2:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/21b14354-6a3a-45e0-8d02-ecc7ec7f7300/public)\n\n```\nInput: head = [1,2]\nOutput: [2,1]\n\n```\n\n**Example 3:**\n\n```\nInput: head = []\nOutput: []\n\n```\n\n**Constraints:**\n\n- The number of nodes in the list is the range `[0, 5000]`.\n- `5000 <= Node.val <= 5000`\n",
  "questions": [
    {
      "questionPrompt": "If we have a linked list with only one node, what will be the result after reversing it?",
      "choices": [
        {
          "choice": "An empty linked list"
        },
        {
          "choice": "The same linked list"
        }
      ],
      "answerIndex": 1,
      "explanation": "Reversing a linked list with only one node doesn't change anything. It remains the same, as there are no other nodes to rearrange."
    },
    {
      "questionPrompt": "In order to reverse a linked list, we need to change the direction of which part of each node?",
      "choices": [
        {
          "choice": "The node's value"
        },
        {
          "choice": "The node's 'next' reference"
        }
      ],
      "answerIndex": 1,
      "explanation": "In a singly linked list, each node has a value and a 'next' reference pointing to the next node in the list. To reverse the list, we need to change the 'next' reference of each node to point to the previous node."
    },
    {
      "questionPrompt": "What could be a simple, but also optimal approach to reverse a linked list?",
      "choices": [
        {
          "choice": "Recursively reverse the linked list in-place."
        },
        {
          "choice": "Use a stack to reverse the values of the linked list in-place."
        },
        {
          "choice": "Traverse the list once, and for each node, set its 'next' to the previous node."
        }
      ],
      "answerIndex": 2,
      "explanation": "Recursion or using a stack would require additional space and isn't necessary. By traversing the list and updating the 'next' reference of each node to point to the previous node, we can achieve the desired result."
    },
    {
      "questionPrompt": "What is the time and space complexity of the optimal approach?\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev, curr = None, head\n        \n        while curr: \n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(1), Space complexity: O(1)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity is O(n) because we need to traverse the list once, where n is the number of nodes in the list. The space complexity is O(1) because we are not using any additional space that scales with the size of the input. We only use a few variables to keep track of the previous and current nodes during the process."
    }
  ],
  "totalRatings": {
    "dislikes": 0,
    "likes": 126
  },
  "totalSubmissions": 1692
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891790"
  },
  "id": "merge-two-sorted-lists",
  "name": "Merge Two Sorted Lists",
  "video": "XIdigk956u0",
  "free": true,
  "pattern": "Linked List",
  "difficulty": "Easy",
  "leetcodePrompt": "\nYou are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn *the head of the merged linked list*.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6bafdf72-dfb3-4085-9372-f34e7361d700/public)\n\n```\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\n```\n\n**Example 2:**\n\n```\nInput: list1 = [], list2 = []\nOutput: []\n\n```\n\n**Example 3:**\n\n```\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\n```\n\n**Constraints:**\n\n- The number of nodes in both lists is in the range `[0, 50]`.\n- `100 <= Node.val <= 100`\n- Both `list1` and `list2` are sorted in **non-decreasing** order.\n",
  "questions": [
    {
      "questionPrompt": "If we have two sorted linked lists, where should we start comparing elements to begin merging them into a single sorted list?",
      "choices": [
        {
          "choice": "From the middle of each list."
        },
        {
          "choice": "From the last element of each list."
        },
        {
          "choice": "From the first element of each list."
        }
      ],
      "answerIndex": 2,
      "explanation": "As both lists are sorted in non-decreasing order, the smallest elements are at the heads of the lists. Hence, we should start comparing from the first elements of each list to create the new sorted list."
    },
    {
      "questionPrompt": "When comparing the first nodes of each list, which node should we insert into the output list?",
      "choices": [
        {
          "choice": "The node with the larger value."
        },
        {
          "choice": "The node with the smaller value."
        },
        {
          "choice": "Any node, the choice doesn't matter."
        }
      ],
      "answerIndex": 1,
      "explanation": "To maintain the sorted order in the output list, we should always insert the node with the smaller value first. If there’s a tie, we can insert either node. This ensures that we are always adding the smallest remaining element to the merged list."
    },
    {
      "questionPrompt": "How should we proceed after inserting a node from one of the lists into the output list?",
      "choices": [
        {
          "choice": "Insert the node from the other list into the output list."
        },
        {
          "choice": "Shift to the next node in both lists and repeat the comparison."
        },
        {
          "choice": "Shift to the next node in the list from which we inserted the node and repeat the comparison."
        }
      ],
      "answerIndex": 2,
      "explanation": "After inserting a node from one of the lists into the output list, we should shift to the next node in the same list. We've already considered the inserted node in the sorting process. Now, it's time to compare the next node from this list with the current node from the other list."
    },
    {
      "questionPrompt": "What if one list becomes empty (all of its nodes are used up) before the other during the merging process?",
      "choices": [
        {
          "choice": "Discard the remaining nodes in the other list."
        },
        {
          "choice": "Append the remaining nodes in the other list to the merged list."
        },
        {
          "choice": "Pick nodes from the exhausted list randomly to fill up the merged list."
        }
      ],
      "answerIndex": 1,
      "explanation": "If one list becomes empty before the other, we can safely append the remaining nodes from the other list to the merged list. As both lists are sorted, the remaining nodes will also be in sorted order."
    },
    {
      "questionPrompt": "What is the time complexity and space complexity of this approach? Assume `m` and `n` are the lengths of list1 and list2 respectively.\n\n```python\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode(0)\n        current = dummy\n\n        while l1 and l2:\n            if l1.val <= l2.val:\n                current.next = l1\n                l1 = l1.next\n            else:\n                current.next = l2\n                l2 = l2.next\n            current = current.next\n\n        current.next = l1 if l1 is not None else l2\n        return dummy.next\n```",
      "choices": [
        {
          "choice": "Time complexity: O(m+n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(m*n), Space complexity: O(m+n)"
        },
        {
          "choice": "Time complexity: O(m+n), Space complexity: O(m+n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity is O(m+n) because in the worst case, we'll have to traverse all nodes of both lists once. The space complexity is O(1) because we're not using any additional space that scales with the input size. We are simply rearranging the existing nodes."
    }
  ],
  "totalRatings": {
    "dislikes": 0,
    "likes": 100
  },
  "totalSubmissions": 1293
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891791"
  },
  "id": "reorder-list",
  "name": "Reorder List",
  "video": "S5bfdUTrKLM",
  "free": true,
  "pattern": "Linked List",
  "difficulty": "Medium",
  "leetcodePrompt": "\nYou are given the head of a singly linked-list. The list can be represented as:\n\n```\nL0 → L1 → … → Ln - 1 → Ln\n```\n\n*Reorder the list to be on the following form:*\n\n```\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n\n```\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/034d3a04-1ca6-4c81-8a7a-648658944600/public)\n\n```\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n\n```\n\n**Example 2:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/80f9be46-c7d9-43bb-b072-3bbfd7942500/public)\n\n```\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n\n```\n\n**Constraints:**\n\n- The number of nodes in the list is in the range `[1, 5 * 10^4]`.\n- `1 <= Node.val <= 1000`\n",
  "questions": [
    {
      "questionPrompt": "Given the list L0 → L1 → … → Ln - 1 → Ln, what is the first step to reorder the list to the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …?",
      "choices": [
        {
          "choice": "Reversing the entire list."
        },
        {
          "choice": "Reversing the second half of the list."
        },
        {
          "choice": "Swapping the first and the last node."
        }
      ],
      "answerIndex": 1,
      "explanation": "To get to the required order, we first need to reverse the second half of the list. This is because the second half of the list is to be interweaved with the first half, but in the reverse order."
    },
    {
      "questionPrompt": "How can you find the middle node of a singly linked list?",
      "choices": [
        {
          "choice": "Starting from the head, move to the next node until you find the middle node."
        },
        {
          "choice": "Use two pointers: a slow pointer moving one step at a time, and a fast pointer moving two steps at a time."
        }
      ],
      "answerIndex": 1,
      "explanation": "We use a technique known as the 'tortoise and the hare' to find the middle of a singly linked list. The slow pointer moves one step at a time while the fast pointer moves two steps at a time. By the time the fast pointer reaches the end of the list, the slow pointer will be at the middle."
    },
    {
      "questionPrompt": "After reversing the second half of the list, how do you reorder the list to the required form?",
      "choices": [
        {
          "choice": "By appending the second half of the list to the first half."
        },
        {
          "choice": "By alternating nodes from the first and second half of the list."
        },
        {
          "choice": "By concatenating the first half of the list to the second half."
        }
      ],
      "answerIndex": 1,
      "explanation": "After reversing the second half of the list, we reorder the list by alternating nodes from the first and second half of the list."
    },
    {
      "questionPrompt": "In the code, what approach is used to merge the two halves of the list into the required form?",
      "choices": [
        {
          "choice": "A new list is created and nodes from both halves are added alternately."
        },
        {
          "choice": "Corresponding nodes from the first and second half of the list are swapped."
        },
        {
          "choice": "At each step, a node is unlinked from the second half and linked into the first half."
        }
      ],
      "answerIndex": 2,
      "explanation": "The provided code merges the two halves by iterating through the first half of the list. At each step, it unlinks a node from the second half and links it into the first half. This results in the desired ordering of nodes."
    },
    {
      "questionPrompt": "Consider the following code for reordering a linked list. What is its time complexity and space complexity?\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def reorderList(self, head: ListNode) -> None:\n        # find middle\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # reverse second half\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        # merge two halves\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "This approach has a linear time complexity O(n) because we are making a single pass to find the middle, a single pass to reverse the second half, and a single pass to merge the two halves. The space complexity is O(1) because we are rearranging the nodes in-place without using additional storage proportional to the input size."
    }
  ],
  "totalRatings": {
    "dislikes": 0,
    "likes": 52
  },
  "totalSubmissions": 924
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891792"
  },
  "id": "remove-nth-node-from-end-of-list",
  "name": "Remove Nth Node From End of List",
  "video": "XVuQxVej6y8",
  "free": true,
  "pattern": "Linked List",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven the `head` of a linked list, remove the `nth` node from the end of the list and return its head.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/23a28313-7f20-49b4-9781-fcf45a598100/public)\n\n```\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\n```\n\n**Example 2:**\n\n```\nInput: head = [1], n = 1\nOutput: []\n\n```\n\n**Example 3:**\n\n```\nInput: head = [1,2], n = 1\nOutput: [1]\n\n```\n\n**Constraints:**\n\n- The number of nodes in the list is `sz`.\n- `1 <= sz <= 30`\n- `0 <= Node.val <= 100`\n- `1 <= n <= sz`\n\n**Follow up:** Could you do this in one pass?\n",
  "questions": [
    {
      "questionPrompt": "In order to remove a node `x` from a singly linked list, which node do we need access to?",
      "choices": [
        {
          "choice": "Node x"
        },
        {
          "choice": "Node before x"
        },
        {
          "choice": "Node after x"
        }
      ],
      "answerIndex": 1,
      "explanation": "To remove a node x from a singly linked list, we need access to the node before x. This is because in a singly linked list, we can only navigate in one direction and there's no reference to the previous node from a given node. By having access to the node before x, we can adjust its next reference to bypass x, effectively removing x from the list."
    },
    {
      "questionPrompt": "An edge case is where we must remove the first node in the list. What is a simple way to eliminate this edge case?",
      "choices": [
        {
          "choice": "Add a dummy node at the end of the list."
        },
        {
          "choice": "Add a dummy node at the beginning of the list."
        },
        {
          "choice": "There is no way to eliminate this edge case."
        }
      ],
      "answerIndex": 1,
      "explanation": "To eliminate the edge case of removing the first node in the list, we can add a dummy node at the beginning of the list. This dummy node won't affect the other operations, but allows us to handle the head of the list in a consistent way with other nodes."
    },
    {
      "questionPrompt": "If we were to solve this problem without precomputing the length of the list, but instead using two pointers, what should the *offset* between the two pointers be? Assume we will iterate until the second pointer reaches null.\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c6af2817-4885-47c2-9f04-8e9603192500/public)",
      "choices": [
        {
          "choice": "n"
        },
        {
          "choice": "n + 1"
        },
        {
          "choice": "n - 1"
        }
      ],
      "answerIndex": 1,
      "explanation": "If we are to solve this problem using two pointers without precomputing the length of the list, the offset between the two pointers should be n + 1. This ensures that the second pointer reaches null right when the first pointer gets to the node before the target node, which is the nth node from the end of the list."
    },
    {
      "questionPrompt": "After we have created the offset, by how much should we shift each pointer on each iteration of the loop?",
      "choices": [
        {
          "choice": "First pointer by 1, Second pointer by 2"
        },
        {
          "choice": "First pointer by 1, Second pointer by 1"
        }
      ],
      "answerIndex": 1,
      "explanation": "After we have created the offset, we should shift each pointer by 1 on each iteration of the loop. This ensures that the offset (the gap between the two pointers) remains constant while traversing the list, allowing us to find the node to be removed."
    },
    {
      "questionPrompt": "What is the time and space complexity of the two-pointer approach for this problem? Assume `n` is the length of the list.\n    \n```python\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n > 0: // Create offset\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        left.next = left.next.next // delete\n        return dummy.next\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The two-pointer approach has a linear time complexity of O(n). We perform a constant amount of work for each node (moving the pointers and eventually deleting a node). The space complexity is O(1) as we are not using any extra space that scales with the input size, we're simply using two pointers to navigate the existing list."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 48
  },
  "totalSubmissions": 865
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891795"
  },
  "id": "merge-k-sorted-lists",
  "name": "Merge K Sorted Lists",
  "video": "q5a5OiGbT6Q",
  "free": true,
  "pattern": "Linked List",
  "difficulty": "Hard",
  "leetcodePrompt": "\nYou are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\n*Merge all the linked-lists into one sorted linked-list and return it.*\n\n**Example 1:**\n\n```markdown\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n```\n\n**Example 2:**\n\n```\nInput: lists = []\nOutput: []\n```\n\n**Example 3:**\n\n```\nInput: lists = [[]]\nOutput: []\n```\n\n**Constraints:**\n\n- `k == lists.length`\n- `0 <= k <= 10^4`\n- `0 <= lists[i].length <= 500`\n- `10^4 <= lists[i][j] <= 10^4`\n- `lists[i]` is sorted in **ascending order**.\n- The sum of `lists[i].length` will not exceed `10^4`.\n",
  "questions": [
    {
      "questionPrompt": "What would be a straightforward but not necessarily optimal approach to solve this problem?",
      "choices": [
        {
          "choice": "Sequentially merge the linked lists, starting from the first one"
        },
        {
          "choice": "Reverse each linked list, and then merge"
        },
        {
          "choice": "Select the last node from each list and create a new sorted list"
        },
        {
          "choice": "Randomly pick two lists to merge until one list is left"
        }
      ],
      "answerIndex": 0,
      "explanation": "A straightforward approach for this problem would involve sequentially merging the linked lists, starting from the first one. This would involve merging the first two lists, then merging the result with the third list, and so on. While this approach is simple, it may not be the most efficient in terms of time complexity."
    },
    {
      "questionPrompt": "What would be the time complexity of the solution where you merge the linked lists one by one into the first linked list? Assume `n` is the total number of nodes, and `k` is the number of linked lists.",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n log n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(kn)"
        }
      ],
      "answerIndex": 3,
      "explanation": "When you merge two linked lists, the time complexity is proportional to the total number of nodes in the two lists. If you merge the linked lists one by one, you'll end up with a time complexity of O(kn) because each merge operation can potentially traverse all n nodes, and this operation is repeated k times."
    },
    {
      "questionPrompt": "Given that all individual linked lists are already sorted, how can you take advantage of this to improve the time complexity?",
      "choices": [
        {
          "choice": "By using a sorting algorithm that is more efficient on nearly sorted lists"
        },
        {
          "choice": "By using a two-pointer technique to find pairs of nodes that sum to a target"
        },
        {
          "choice": "By merging the linked lists two at a time"
        },
        {
          "choice": "By using a priority queue to select the next smallest node"
        }
      ],
      "answerIndex": 3,
      "explanation": "Since all individual linked lists are sorted, you can use a priority queue (also known as a min-heap) to efficiently select the next smallest node from the heads of all the linked lists."
    },
    {
      "questionPrompt": "If you use a priority queue to keep track of the smallest node in each linked list, what would be the time complexity of inserting an element into the queue?",
      "choices": [
        {
          "choice": "O(1)"
        },
        {
          "choice": "O(log k)"
        },
        {
          "choice": "O(k)"
        },
        {
          "choice": "O(n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity of inserting an element into a priority queue (or min-heap) is O(log k), where k is the number of linked lists (or the current size of the heap). Each insert operation might need to restructure the heap to maintain its properties, which takes logarithmic time."
    },
    {
      "questionPrompt": "If you use a priority queue to select the smallest node from each linked list, what would be the time complexity for merging all the linked lists into one sorted list?",
      "choices": [
        {
          "choice": "O(n log n)"
        },
        {
          "choice": "O(n log k)"
        },
        {
          "choice": "O(k log n)"
        },
        {
          "choice": "O(n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "If you use a priority queue, you are essentially removing the smallest element (head of some linked list) and then adding the next element from the same list. Each operation (insert/remove) would take O(log k) time. Since we are doing these operations for all 'n' nodes, the total time complexity would be O(n log k)."
    },
    {
      "questionPrompt": "If you use a priority queue to select the smallest node from each linked list, what would be the space complexity for merging all the linked lists into one sorted list?",
      "choices": [
        {
          "choice": "O(1)"
        },
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(k)"
        },
        {
          "choice": "O(n + k)"
        }
      ],
      "answerIndex": 2,
      "explanation": "In this case, the space complexity is O(k) because at any point, you only need to store the head nodes of each linked list in the priority queue. Here, k is the number of linked lists."
    }
  ],
  "totalRatings": {
    "dislikes": 8,
    "likes": 70
  },
  "totalSubmissions": 1098
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891796"
  },
  "id": "invert-binary-tree",
  "name": "Invert a Binary Tree",
  "video": "OnSn2XEQ4MY",
  "free": true,
  "pattern": "Trees",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven the `root` of a binary tree, invert the tree, and return *its root*.\n\n\n![Binary Tree Inverted](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9aeb8e98-e369-4a36-2c82-be3efcab4f00/public)\n\n**Example 1:**\n\n```\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n ```\n\n**Constraints:**\n\n- The number of nodes in the tree is in the range `[0, 100]`.\n- `-100 <= Node.val <= 100`\n",
  "questions": [
    {
      "questionPrompt": "What does this binary tree look like after it has been inverted? ![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3632af86-32d0-4224-fd47-1a9f311a8f00/public)",
      "choices": [
        {
          "choice": "https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/00d65115-0868-4312-8050-b1b039ecda00/public",
          "isImage": true
        },
        {
          "choice": "https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/22600c7e-0bb6-4762-9959-370044446b00/public",
          "isImage": true
        }
      ],
      "answerIndex": 1,
      "explanation": "Inverting a binary tree means to make all left child nodes become right child nodes and vice versa. This is effectively the same as swapping the left and right child nodes for every node in the tree."
    },
    {
      "questionPrompt": "Which tree traversal can be used to solve this problem?",
      "choices": [
        {
          "choice": "Depth-First Search (DFS)"
        },
        {
          "choice": "Breadth-First Search (BFS)"
        },
        {
          "choice": "Neither DFS nor BFS"
        },
        {
          "choice": "Both DFS and BFS"
        }
      ],
      "answerIndex": 3,
      "explanation": "Both Depth-First Search (DFS) and Breadth-First Search (BFS) could be used to solve this problem. Both methods would work because the order in which we visit the nodes doesn't matter in this problem, as long as every node’s children are swapped."
    },
    {
      "questionPrompt": "If we were to use a recursive DFS approach to solve this problem, what would be the base case?",
      "choices": [
        {
          "choice": "When we encounter a null node"
        },
        {
          "choice": "When we encounter a leaf node"
        },
        {
          "choice": "Neither A nor B"
        },
        {
          "choice": "Either one of A or B would be a sufficient base case"
        }
      ],
      "answerIndex": 3,
      "explanation": "The base case for a recursive approach to this problem could be when we encounter a null node. This is because we cannot swap the left and right children of a null node. But an alternative base case could be when we encounter a leaf node, since the node doesn’t have any children to swap."
    },
    {
      "questionPrompt": "With the recursive approach in mind, how would we invert a binary tree?",
      "choices": [
        {
          "choice": "Swap the left and right children of the root node, then recursively invert the left and right subtrees"
        },
        {
          "choice": "Recursively invert the left subtree, then the right subtree, then swap the left and right children of the root node"
        },
        {
          "choice": "Recursively invert the right subtree, then the left subtree, then swap the left and right children of the root node"
        },
        {
          "choice": "Any of the above."
        }
      ],
      "answerIndex": 3,
      "explanation": "The recursive approach to inverting a binary tree would involve swapping the left and right children of the root node, as well as recursively inverting the left subtree, and the right subtree. But it doesn’t matter the order we execute these operations because none of them interfere with each other."
    },
    {
      "questionPrompt": "What are the time and space complexities of the recursive solution to this problem? Assume the binary tree is balanced and contains n nodes.",
      "choices": [
        {
          "choice": "Time complexity: O(1), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(log n)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(n^2)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity of the recursive solution is O(n), where n is the number of nodes in the tree. This is because we have to visit every node in the tree once in order to swap its left and right children. The space complexity is O(log n) in the average case, because the maximum amount of space we'll need corresponds to the depth of the tree, which in a balanced binary tree is log(n). In the worst case scenario (a completely unbalanced tree), it could be O(n), but generally, we consider the average case for space complexity in recursive solutions."
    }
  ],
  "totalRatings": {
    "dislikes": 4,
    "likes": 132
  },
  "totalSubmissions": 1605
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a891797"
  },
  "id": "maximum-depth-of-binary-tree",
  "name": "Maximum Depth of Binary Tree",
  "video": "hTM3phVI6YQ",
  "free": true,
  "pattern": "Trees",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven the `root` of a binary tree, return *its maximum depth*.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4601cb74-8473-4e92-bf42-b0406178d900/public)\n\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\n```\n\n**Example 2:**\n\n```\nInput: root = [1,null,2]\nOutput: 2\n\n```\n\n**Constraints:**\n\n- The number of nodes in the tree is in the range `[0, 10^4]`.\n- `100 <= Node.val <= 100`\n",
  "questions": [
    {
      "questionPrompt": "What is the maximum depth of a binary tree with a single node?",
      "choices": [
        {
          "choice": "0"
        },
        {
          "choice": "1"
        },
        {
          "choice": "2"
        },
        {
          "choice": "The depth is undefined for a single node tree."
        }
      ],
      "answerIndex": 1,
      "explanation": "A tree with a single node (which is also the root) has a maximum depth of 1. The depth of a tree is the number of nodes along the longest path from the root node down to the farthest leaf node. Here, that path consists only of the root node itself."
    },
    {
      "questionPrompt": "Which tree traversal technique could be utilized to find the maximum depth of a binary tree?",
      "choices": [
        {
          "choice": "Depth-First Search (DFS)"
        },
        {
          "choice": "Breadth-First Search (BFS)"
        },
        {
          "choice": "Both DFS and BFS"
        },
        {
          "choice": "Neither DFS nor BFS"
        }
      ],
      "answerIndex": 2,
      "explanation": "Both DFS and BFS can be used to solve this problem. Both methods would work because they both can explore the full depth of the tree. There is no inherent efficiency gain in this particular problem for DFS over BFS or vice versa, as we would need to traverse all nodes to ensure we've found the maximum depth."
    },
    {
      "questionPrompt": "If we use a recursive DFS approach to solve this problem, what would be a sensible base case?",
      "choices": [
        {
          "choice": "When we encounter a null node"
        },
        {
          "choice": "When we encounter a node with only one child"
        },
        {
          "choice": "There is no need for a base case"
        }
      ],
      "answerIndex": 0,
      "explanation": "A good base case for this problem could be when we encounter a null node. When we reach a null node, it indicates we've traversed all the way down one path of the tree and we've hit a leaf node in the previous step."
    },
    {
      "questionPrompt": "Considering the recursive approach, how would we compute the maximum depth of a binary tree?",
      "choices": [
        {
          "choice": "Compare the depth of the left subtree and the right subtree, then return the maximum plus 1"
        },
        {
          "choice": "Add the depths of the left subtree and the right subtree"
        },
        {
          "choice": "Return the depth of the left subtree if it is non-null, else return the depth of the right subtree"
        }
      ],
      "answerIndex": 0,
      "explanation": "The maximum depth of a binary tree is one more than the maximum of the depths of its left and right subtrees. So, we recursively compute the maximum depths of the left and right subtrees, and the maximum depth of the tree is the maximum of these two depths plus 1."
    },
    {
      "questionPrompt": "Given the below Python function to solve the problem, what are the time and space complexities? Assume the binary tree is balanced.\n    \n```python\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(\n            self.maxDepth(root.left),\n            self.maxDepth(root.right)\n        )\n```",
      "choices": [
        {
          "choice": "Time complexity: O(1), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(log n)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity of the recursive solution is O(n), where n is the number of nodes in the tree. We visit each node once, so the time complexity is proportional to the size of the tree. The space complexity is O(log n) in the average case (for a balanced tree), as we only need to store information up to the depth of the tree, which is log(n) for a balanced binary tree. In the worst case (a completely unbalanced tree), the space complexity could be O(n)."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 49
  },
  "totalSubmissions": 1006
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89179a"
  },
  "id": "same-tree",
  "name": "Same Tree",
  "video": "vRbbcKXCxOw",
  "free": true,
  "pattern": "Trees",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1168b33f-0718-49d2-3991-d2e92b1ae500/public)\n\n```\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\n```\n\n**Example 2:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/753a6eeb-7153-4c61-096f-438a4ccd9400/public)\n\n```\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\n```\n\n**Example 3:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/76cda15a-858b-4702-d319-badd1fb6da00/public)\n\n```\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n```\n\n**Constraints:**\n\n- The number of nodes in both trees is in the range `[0, 100]`.\n- `10^4 <= Node.val <= 10^4`\n",
  "questions": [
    {
      "questionPrompt": "Which of the following factors would be considered when determining if two binary trees are the same?",
      "choices": [
        {
          "choice": "The structure of the trees."
        },
        {
          "choice": "The values of the nodes in the trees."
        },
        {
          "choice": "Both A and B."
        }
      ],
      "answerIndex": 2,
      "explanation": "Two binary trees are considered the same if they are structurally identical and the nodes have the same value."
    },
    {
      "questionPrompt": "What would be a base case to check if two subtrees `p` and `q` are the same in the recursive approach to this problem?",
      "choices": [
        {
          "choice": "When both p and q are null."
        },
        {
          "choice": "When either p or q is null."
        }
      ],
      "answerIndex": 0,
      "explanation": "The base case for this problem is when both nodes are null. If both nodes are null, then we can say they are the same."
    },
    {
      "questionPrompt": "What would be a base case to check if two subtrees `p` and `q` are *not* the same in the recursive approach to this problem?",
      "choices": [
        {
          "choice": "When either p or q is null, but not both."
        },
        {
          "choice": "When the values of p and q differ."
        },
        {
          "choice": "Both A and B."
        }
      ],
      "answerIndex": 2,
      "explanation": "If only one of them is null, they are not the same. Similarly, if the values of p and q are different, they are not the same."
    },
    {
      "questionPrompt": "If the base case does *not* hold, what should be checked to confirm whether the two subtrees are the same?",
      "choices": [
        {
          "choice": "Compare the values of the nodes and check if the left and right subtrees of the nodes are the same."
        },
        {
          "choice": "Check if the left subtree of one node is the same as the right subtree of the other node."
        },
        {
          "choice": "Compare only the values of the nodes."
        }
      ],
      "answerIndex": 0,
      "explanation": "If both nodes are not null, we need to check if the values of the nodes are the same and if the left subtree of the first node is the same as the left subtree of the second node, and the same for the right subtrees."
    },
    {
      "questionPrompt": "Considering the below Python function to solve the problem, where `n` and `m` are the number of nodes in the first and second tree respectively, and `h1` and `h2` are the heights of the first and second tree respectively. What are the time and space complexities?\n    \n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return (\n            self.isSameTree(p.left, q.left) and\n            self.isSameTree(p.right, q.right)\n        )\n```",
      "choices": [
        {
          "choice": "Time complexity: O(1), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(min(n, m)), Space complexity: O(min(h1, h2))"
        },
        {
          "choice": "Time complexity: O(max(n, m)), Space complexity: O(max(h1, h2))"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity of the recursive solution is O(min(n, m)), where n and m are the number of nodes in the first and second tree, respectively. We stop as soon as we find a difference between the trees, which could be at a size smaller than the larger tree. The space complexity is O(min(h1, h2)) in the worst case, which is determined by the maximum amount of space required by the recursive stack. The worst-case occurs in situations where the tree is completely unbalanced (e.g., each node only contains a left / right child node), leading to a maximum recursion depth of h (height of the tree). However, because we are comparing two trees, the maximum recursion depth would be the minimum height of the two trees."
    }
  ],
  "totalRatings": {
    "dislikes": 0,
    "likes": 60
  },
  "totalSubmissions": 957
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89179b"
  },
  "id": "subtree-of-another-tree",
  "name": "Subtree of Another Tree",
  "video": "E36O5SWp-LE",
  "free": true,
  "pattern": "Trees",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/52b41f82-273f-4b31-83ea-f6895eb79200/public)\n\n```\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n\n```\n\n**Example 2:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc852005-42e7-434d-3514-e5c834361b00/public)\n\n```\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false\n\n```\n\n**Constraints:**\n\n- The number of nodes in the `root` tree is in the range `[1, 2000]`.\n- The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.\n- `10^4 <= root.val <= 10^4`\n- `10^4 <= subRoot.val <= 10^4`\n",
  "questions": [
    {
      "questionPrompt": "What is a subtree in the context of binary trees?",
      "choices": [
        {
          "choice": "Any node along with all its descendants in the original tree."
        },
        {
          "choice": "A tree that only consists of leaf nodes of the original tree."
        },
        {
          "choice": "A smaller tree that has the same root node as the original tree."
        }
      ],
      "answerIndex": 0,
      "explanation": "A subtree of a binary tree is a tree that consists of a node in the original tree and all of this node's descendants. The tree could also be considered a subtree of itself."
    },
    {
      "questionPrompt": "Considering the problem of finding a subtree within a tree which tree traversal technique could be utilized?",
      "choices": [
        {
          "choice": "Depth-First Search (DFS)"
        },
        {
          "choice": "Breadth-First Search (BFS)"
        },
        {
          "choice": "Both DFS and BFS"
        }
      ],
      "answerIndex": 2,
      "explanation": "Both DFS and BFS can be used to solve this problem. These tree traversal techniques allow us to check each node in the root tree and compare it with the subRoot tree."
    },
    {
      "questionPrompt": "When trying to determine if a `subRoot` is a subtree of `root`, which kind of helper function might be beneficial to have?",
      "choices": [
        {
          "choice": "A function to calculate the height of root and subroot"
        },
        {
          "choice": "A function to compare two trees and check if they are identical"
        }
      ],
      "answerIndex": 1,
      "explanation": "A helper function that compares two trees to check if they are identical can be useful. We can use it every time we find a node in `root` that is the same as the root of `subRoot`. We then compare the entire structure starting from this node with `subRoot` using this helper function."
    },
    {
      "questionPrompt": "Given a tree `root` and a `subRoot`, if we find a node in `root` with the same value as the root of `subRoot`, what should be our next step?",
      "choices": [
        {
          "choice": "Return true as we have found subroot in root"
        },
        {
          "choice": "Check if the subtree at the found node in root is identical to subroot"
        },
        {
          "choice": "Check if the left child of the found node in root is identical to the left child of subroot"
        }
      ],
      "answerIndex": 1,
      "explanation": "Just finding a node with the same value does not confirm the presence of the subtree. We need to verify if the entire structure of the subtree starting at this node is identical to subroot."
    },
    {
      "questionPrompt": "Given the below Python solution to solve the problem, what are the time and space complexities of the `isSubtree` function? Assume the tree may not be balanced.\n    \n```python\nclass Solution:\n    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:\n        if not t: return True\n        if not s: return False\n\n        if self.sameTree(s, t):\n            return True\n        return (self.isSubtree(s.left, t) or\n                self.isSubtree(s.right, t))\n\n    def sameTree(self, s, t):\n        if not s and not t:\n            return True\n        if s and t and s.val == t.val:\n            return (self.sameTree(s.left, t.left) and\n                    self.sameTree(s.right, t.right))\n        return False\n```",
      "choices": [
        {
          "choice": "Time complexity: O(mn), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(m+n), Space complexity: O(m+n)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(log n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity of this solution is O(mn), where m and n are the number of nodes in root and subroot, respectively. This is because, in the worst case, for each node in root, we may have to traverse all nodes in subroot to check if they form the same tree (i.e., in the sameTree function). The space complexity is O(n) in the worst case (for an unbalanced tree) because of the potential stack space needed for the DFS traversal. However, if the tree is balanced, the space complexity would be O(log n) as the maximum depth of the tree (and thus the maximum stack size) would be log n."
    }
  ],
  "totalRatings": {
    "dislikes": 2,
    "likes": 39
  },
  "totalSubmissions": 771
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89179c"
  },
  "id": "lowest-common-ancestor-of-a-binary-search-tree",
  "name": "Lowest Common Ancestor of a Binary Search Tree",
  "video": "gs2LMfuOR9k",
  "free": true,
  "pattern": "Trees",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6a944957-3b32-4eab-37ab-48b701a70000/public)\n\n```\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n\n```\n\n**Example 2:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe9f02bd-c21c-4dac-d6c5-1962775c0800/public)\n\n```\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n```\n\n**Example 3:**\n\n```\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\n\n```\n\n**Constraints:**\n\n- The number of nodes in the tree is in the range `[2, 10^5]`.\n- `10^9 <= Node.val <= 10^9`\n- All `Node.val` are **unique**.\n- `p != q`\n- `p` and `q` will exist in the BST.\n",
  "questions": [
    {
      "questionPrompt": "In a BST, for any given node `n`, which of the following is true?",
      "choices": [
        {
          "choice": "All nodes in the left subtree of n are greater than n, and all nodes in the right subtree are less than n."
        },
        {
          "choice": "All nodes in the left subtree of n are less than n, and all nodes in the right subtree are greater than n."
        }
      ],
      "answerIndex": 1,
      "explanation": "By definition, in a Binary Search Tree, for any given node n, all nodes in the left subtree of n are less than n, and all nodes in the right subtree are greater than n."
    },
    {
      "questionPrompt": "If `p` and `q` are both less than the root, where should we search for their `LCA` in a BST?",
      "choices": [
        {
          "choice": "In the root's right subtree."
        },
        {
          "choice": "In the root's left subtree."
        },
        {
          "choice": "In both the root's left and right subtrees."
        },
        {
          "choice": "Only in the root itself."
        }
      ],
      "answerIndex": 1,
      "explanation": "Given the properties of a BST, if both p and q are less than the root, then their LCA must be in the root's left subtree."
    },
    {
      "questionPrompt": "If p and q are on different sides of the root (i.e., one is less than the root and the other is greater), where is their LCA?",
      "choices": [
        {
          "choice": "It is the root."
        },
        {
          "choice": "It is in the root's left subtree."
        },
        {
          "choice": "It is in the root's right subtree."
        }
      ],
      "answerIndex": 0,
      "explanation": "Given the properties of a BST, if p and q are on different sides of the root, the root is the LCA. This is because all values in the left subtree are less than the root, and all values in the right subtree are greater."
    },
    {
      "questionPrompt": "If the `cur` node in the search is either **`p`** or **`q`**, then what will be the LCA?\n",
      "choices": [
        {
          "choice": "The LCA will be the root node."
        },
        {
          "choice": "The LCA will be p or q, whichever is the current node."
        },
        {
          "choice": "The LCA will be the other node that is not the current node."
        }
      ],
      "answerIndex": 1,
      "explanation": "Given the property of a BST and the definition of LCA, if the current node is either **`p`** or **`q`**, then this node will be the LCA. This is because a node can be a descendant of itself, and this node will be the lowest common node that has both **`p`** and **`q`** as descendants."
    },
    {
      "questionPrompt": "Given the below Python function to solve the problem, what are the time and space complexities? Assume there are `n` nodes in the tree and the tree is balanced.\n\n```python\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        cur = root\n\n        while cur:\n            if p.val > cur.val and q.val > cur.val:\n                cur = cur.right\n            elif p.val < cur.val and q.val < cur.val:\n                cur = cur.left\n            else:\n                return cur\n```",
      "choices": [
        {
          "choice": "Time complexity: O(log n), Space complexity: O(log n)"
        },
        {
          "choice": "Time complexity: O(log n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity of this solution is O(log n), where n is the number of nodes in the tree. This is because we are essentially performing a binary search, narrowing down our search to either the left or right subtrees each time, which gives a log(n) time complexity. The space complexity is O(1), because this approach only uses a constant amount of space and doesn't depend on the size of the input tree."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 49
  },
  "totalSubmissions": 746
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a89179d"
  },
  "id": "binary-tree-level-order-traversal",
  "name": "Binary Tree Level Order Traversal",
  "video": "6ZnyEApgFYg",
  "free": true,
  "pattern": "Trees",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level).\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e9bf9a5e-fd98-48e2-0967-a1d246f32100/public)\n\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\n```\n\n**Example 2:**\n\n```\nInput: root = [1]\nOutput: [[1]]\n\n```\n\n**Example 3:**\n\n```\nInput: root = []\nOutput: []\n\n```\n\n**Constraints:**\n\n- The number of nodes in the tree is in the range `[0, 2000]`.\n- `1000 <= Node.val <= 1000`\n",
  "questions": [
    {
      "questionPrompt": "How would you traverse a binary tree in a level order fashion?",
      "choices": [
        {
          "choice": "By using Depth-First Search (DFS)"
        },
        {
          "choice": "By using Breadth-First Search (BFS)"
        }
      ],
      "answerIndex": 1,
      "explanation": "Level order traversal of a binary tree is also known as Breadth-First Search (BFS) traversal."
    },
    {
      "questionPrompt": "What data structure is typically used for BFS traversal in a binary tree?",
      "choices": [
        {
          "choice": "Stack"
        },
        {
          "choice": "Queue"
        },
        {
          "choice": "LinkedList"
        },
        {
          "choice": "Array"
        }
      ],
      "answerIndex": 1,
      "explanation": "BFS typically uses a Queue data structure. As you visit a node, you would add its children to the queue, then move on to the next node in the queue, continually adding their children. This way, you naturally visit the nodes level by level."
    },
    {
      "questionPrompt": "For level order traversal, when do we start a new level in the output?",
      "choices": [
        {
          "choice": "When we have visited all the nodes in the current level"
        },
        {
          "choice": "When the tree has no more levels to traverse"
        }
      ],
      "answerIndex": 0,
      "explanation": "We start a new level in the output when we have visited all the nodes in the current level. This can be tracked by recording the size of the queue before starting a new level, and then dequeueing that many nodes for the current level."
    },
    {
      "questionPrompt": "Given the below Python function to solve the problem, what are the time and space complexities? Assume there are `n` nodes in the tree.\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        res = []\n        q = collections.deque()\n        if root: q.append(root)\n\n        while q:\n            val = []\n\n            for i in range(len(q)):\n                node = q.popleft()\n                val.append(node.val)\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n            res.append(val)\n        return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(log n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity of a level order traversal (or BFS) is O(n), where n is the number of nodes in the tree, as we need to visit every node. The space complexity is also O(n), as we need to store every node in the queue in the worst-case scenario (consider a full binary tree's last level)."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 42
  },
  "totalSubmissions": 774
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a0"
  },
  "id": "number-of-islands",
  "name": "Number of Islands",
  "video": "pV2kpPD66nE",
  "free": true,
  "pattern": "Graph",
  "difficulty": "Medium",
  "leetcodePrompt": "Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n \n\n**Example 1:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```",
  "questions": [
    {
      "questionPrompt": "Which graph algorithm can be used to solve this problem?",
      "choices": [
        {
          "choice": "Depth-first search"
        },
        {
          "choice": "Breadth-first search"
        },
        {
          "choice": "Both DFS and BFS"
        },
        {
          "choice": "Neither"
        }
      ],
      "answerIndex": 2,
      "explanation": "Both depth-first search (DFS) and breadth-first search (BFS) can be used to solve this problem. They can both traverse all the connected '1's (land) starting from any given '1', and thus identify an island."
    },
    {
      "questionPrompt": "Assume we are solving this by running a recursive depth-first search on each island. Under what conditions (base cases) should we stop recursing in our search algorithm?",
      "choices": [
        {
          "choice": "When all the cells in the grid have been visited."
        },
        {
          "choice": "When we reach a visited land cell."
        },
        {
          "choice": "When we reach an unvisited land cell."
        },
        {
          "choice": "When we reach a water cell, or reach a visited land cell, or go out of bounds."
        }
      ],
      "answerIndex": 3,
      "explanation": "We should stop the recursion in our search algorithm when we reach a water cell ('0'), or reach a cell that has been already visited, or go out of the bounds of the grid. This ensures we only count connected land ('1's) as part of the same island and we don't overcount or go beyond the grid boundaries."
    },
    {
      "questionPrompt": "What happens if we don’t mark a piece of land as visited after visiting it?",
      "choices": [
        {
          "choice": "We will get stuck in an infinite recusive call stack (timeout or stackoverflow)."
        },
        {
          "choice": "We will count the same island multiple times."
        },
        {
          "choice": "We may miss counting some of the islands."
        }
      ],
      "answerIndex": 0,
      "explanation": "If we don't mark a piece of land as visited after visiting it, our DFS or BFS traversal will revisit the same cell again and again. This would eventually result in a timeout or stackoverflow error."
    },
    {
      "questionPrompt": "What should be our approach to traverse the grid to find the number of islands?",
      "choices": [
        {
          "choice": "Traverse the entire grid and start a DFS or BFS search from each land cell."
        },
        {
          "choice": "Traverse the entire grid and start a DFS or BFS search from each visited land cell."
        },
        {
          "choice": "Traverse the entire grid and start a DFS or BFS search from each unvisited land cell."
        }
      ],
      "answerIndex": 2,
      "explanation": "We should traverse the entire grid and start a DFS or BFS search from each unvisited land cell. This approach ensures that we cover all islands, as each unvisited '1' we encounter would represent a new island."
    },
    {
      "questionPrompt": "What is the time complexity of the solution for this problem?",
      "choices": [
        {
          "choice": "O(m * n)"
        },
        {
          "choice": "O(m^2 * n^2)"
        },
        {
          "choice": "O(m + n)"
        },
        {
          "choice": "O(m * n * log(m * n))"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity of the solution is O(m * n), where m and n are the number of rows and columns in the grid, respectively. This is because in the worst-case scenario, we might have to visit all cells in the grid."
    },
    {
      "questionPrompt": "What is the space complexity of the solution for this problem when using DFS?",
      "choices": [
        {
          "choice": "O(m * n)"
        },
        {
          "choice": "O(m + n)"
        },
        {
          "choice": "O(min(m, n))"
        },
        {
          "choice": "O(max(m, n))"
        }
      ],
      "answerIndex": 0,
      "explanation": "The space complexity of the solution when using DFS is O(m * n), where m and n are the number of rows and columns in the grid, respectively. This is because in the worst-case scenario, the depth of the recursion (the call stack) could be the number of cells in the grid if every cell is land ('1')."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 164
  },
  "totalSubmissions": 1638
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a1"
  },
  "id": "combination-sum",
  "name": "Combination Sum",
  "video": "GBKI9VSKdGg",
  "free": true,
  "pattern": "Backtracking",
  "difficulty": "Medium",
  "leetcodePrompt": "Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in **any order**.\n\nThe **same** number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the \nfrequency\n of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n\n \n\n**Example 1:**\n```\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n```",
  "questions": [
    {
      "questionPrompt": "In order to find all distinct combinations that sum to the target, can we solve this recursively using a decision tree?",
      "choices": [
        {
          "choice": "Yes"
        },
        {
          "choice": "No"
        }
      ],
      "answerIndex": 0,
      "explanation": "Yes, a recursive approach using a decision tree is a suitable method for this problem. Since we must generate each combination, we can not do better than a brute force approach."
    },
    {
      "questionPrompt": "Other than when our sum == target, when should we stop recursing?",
      "choices": [
        {
          "choice": "When the sum is greater than the target."
        },
        {
          "choice": "When we reach the end of the candidates array."
        },
        {
          "choice": "When we have exhausted all possible combinations."
        },
        {
          "choice": "Both A and B."
        }
      ],
      "answerIndex": 3,
      "explanation": "We should stop recursing when the sum is greater than the target or when we reach the end of the candidates array. In the former case, any further recursion will only increase the sum beyond the target. In the latter case, we've exhausted all possible combinations."
    },
    {
      "questionPrompt": "In our decision tree, for each element in the array we will create a branch, where we choose to either include that element only once or skip it entirely. Will this find all combinations?",
      "choices": [
        {
          "choice": "Yes"
        },
        {
          "choice": "No"
        }
      ],
      "answerIndex": 1,
      "explanation": "No, this won't find all combinations. Because the same number may be chosen from candidates an unlimited number of times, we need to consider including each element more than once."
    },
    {
      "questionPrompt": "In our decision tree, for each element in the array we will create a branch, where we choose to either include that element one or more times, or skip it entirely. Will this find all combinations?",
      "choices": [
        {
          "choice": "Yes"
        },
        {
          "choice": "No"
        }
      ],
      "answerIndex": 0,
      "explanation": "Yes, this will find all combinations. By including each element one or more times, we cover all potential combinations that sum up to the target."
    },
    {
      "questionPrompt": "What is the time complexity of the previous solution?",
      "choices": [
        {
          "choice": "O(2^target)"
        },
        {
          "choice": "O(2^(target + n))"
        },
        {
          "choice": "O(n*target)"
        },
        {
          "choice": "O(n^2)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity is O(n^(target + n)), where n is the number of candidates and target is the target sum. This is because, in the worst case the height of our tree may be n + target, since we have a level in the tree for each element in the array. If we have a '1' value, we may choose it 'target' number of times to sum up to the target value, further adding to the height. There will be 2 branches for each node in the tree, one to include the element and one to skip it. Thus, the time complexity is O(2^(n + target))."
    }
  ],
  "totalRatings": {
    "dislikes": 8,
    "likes": 85
  },
  "totalSubmissions": 1229
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a2"
  },
  "id": "house-robber",
  "name": "House Robber",
  "video": "73r3KWiEvyk",
  "free": true,
  "pattern": "Dynamic Programming",
  "difficulty": "Medium",
  "leetcodePrompt": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.\n\n \n\n**Example 1:**\n```\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```",
  "questions": [
    {
      "questionPrompt": "What are the possible decisions to make when robbing houses along the street?",
      "choices": [
        {
          "choice": "Rob every house."
        },
        {
          "choice": "Rob only the houses with the maximum amount of money."
        },
        {
          "choice": "Rob houses while skipping one or more houses to avoid adjacent houses."
        }
      ],
      "answerIndex": 2,
      "explanation": "The correct decision is to rob houses while skipping one or more houses to avoid adjacent houses. Since the problem statement mentions that adjacent houses cannot be robbed on the same night, the strategy should involve skipping one or more houses."
    },
    {
      "questionPrompt": "What is the brute-force solution to this problem?",
      "choices": [
        {
          "choice": "Try every possible combination of non-adjacent houses and find the maximum sum."
        },
        {
          "choice": "Rob the house with the maximum amount of money, then move on to the next unrobbed house."
        },
        {
          "choice": "Rob houses in a strictly increasing order of money."
        },
        {
          "choice": "Rob houses in a strictly decreasing order of money."
        }
      ],
      "answerIndex": 0,
      "explanation": "The brute-force solution is to try every possible combination of non-adjacent houses and find the maximum sum. This involves evaluating all possible combinations of houses where no two houses are adjacent."
    },
    {
      "questionPrompt": "If we implement the brute-force approach using recursion, what will be our decisions as we go through the array?",
      "choices": [
        {
          "choice": "Choice 1 = Rob the current house and go to the next house and continue making decisions. Choice 2 = Skip the current house altogether."
        },
        {
          "choice": "Choice 1 = Rob the current house and skip the next house and continue making decisions. Choice 2 = Skip the current house altogether."
        }
      ],
      "answerIndex": 1,
      "explanation": "This ensures that we don't rob two adjacent houses."
    },
    {
      "questionPrompt": "What is the time complexity of the recursive solution?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(n^3)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 3,
      "explanation": "The time complexity of the recursive solution is O(2^n). In the worst case, we might end up exploring each possible combination of houses, leading to an exponential time complexity."
    },
    {
      "questionPrompt": "We want to use memoization to improve the efficiency of the recursive solution. What subproblem should we cache the result of? Assume we start our recursion at the beginning of the array.",
      "choices": [
        {
          "choice": "If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the right of index i. We can store this in a hashmap or an array by mapping the index to maximum amount."
        },
        {
          "choice": "If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the left of index i. We can store this in a hashmap or an array by mapping the index to maximum amount."
        }
      ],
      "answerIndex": 0,
      "explanation": "If we start at the beginning of the array, each recursive call is a subproblem of the maximum we can rob only from a postfix of the array. The result of a subproblem allows us to solve a slightly larger subproblem."
    },
    {
      "questionPrompt": "What is the time complexity of the memoization solution?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(n^3)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity of the memoization solution is O(n), where n is the number of houses. This is because with memoization, we only solve each subproblem once."
    },
    {
      "questionPrompt": "How can we solve this problem using dynamic programming? Assume we start robbing at the beginning of the array.",
      "choices": [
        {
          "choice": "If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the right of index i. We can store this in a hashmap or an array after we compute it."
        },
        {
          "choice": "If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the left of index i. We can store this in a hashmap or an array after we compute it."
        }
      ],
      "answerIndex": 1,
      "explanation": "If we start at the beginning of the array, on each iteration we are solving a new subproblem - a prefix of the array. The result of previous subproblems will be used to compute the next one."
    },
    {
      "questionPrompt": "What is the time complexity of the dynamic programming solution?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n^2)"
        },
        {
          "choice": "O(n^3)"
        },
        {
          "choice": "O(2^n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity of the dynamic programming solution is O(n), where n is the number of houses. Each subproblem is solved only once and used for future computations, thus leading to a linear time complexity."
    }
  ],
  "totalRatings": {
    "dislikes": 16,
    "likes": 109
  },
  "totalSubmissions": 1428
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a3"
  },
  "id": "rotate-image",
  "name": "Rotate Image",
  "video": "fMSJSS7eO1w",
  "free": true,
  "pattern": "Math & Geometry",
  "difficulty": "Medium",
  "leetcodePrompt": "\nYou are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0e39a867-7e9c-4189-2b4e-1f6335868600/public)\n\n```\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\n```\n\n**Example 2:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a7e0dfba-646e-423e-2c4e-a6f0dfc2a500/public)\n\n```\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n```\n\n**Constraints:**\n\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 20`\n- `1000 <= matrix[i][j] <= 1000`\n",
  "questions": [
    {
      "questionPrompt": "Which approach is more suitable for rotating the matrix in-place (without allocating a new matrix)?",
      "choices": [
        {
          "choice": "Swapping elements along the diagonal."
        },
        {
          "choice": "Creating a new matrix and copying elements into it."
        },
        {
          "choice": "Rotating each layer of the matrix starting from the outside and moving inwards."
        }
      ],
      "answerIndex": 2,
      "explanation": "Rotating each layer of the matrix starting from the outside and moving inwards is the most suitable way to rotate a matrix in-place. The other methods either don't result in a rotated matrix, or require additional space. There are other ways to rotate the matrix in-place, but this is the most intuitive and doesn't require math knowledge."
    },
    {
      "questionPrompt": "Given an `n x n` square matrix, how many layers will we have to rotate?",
      "choices": [
        {
          "choice": "n layers"
        },
        {
          "choice": "n/2 layers"
        },
        {
          "choice": "2n layers"
        },
        {
          "choice": "n^2 layers"
        }
      ],
      "answerIndex": 1,
      "explanation": "For an nxn matrix, we only need to rotate n/2 layers. This is because with each layer, we are actually rotating 4 sides (top, right, bottom, left) of the square matrix."
    },
    {
      "questionPrompt": "If we consider a layer-by-layer rotation starting from the corners, which will be the next four elements to be rotated after the four corners?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d01c9636-cfee-4f7c-3fbb-ddb051090300/public)",
      "choices": [
        {
          "choice": "2nd element in first row, 2nd element in the first column, 2nd element in last row, 2nd element in last column"
        },
        {
          "choice": "2nd element in first row, 2nd element in last column, second to last element in last row, second to last element in first column"
        }
      ],
      "answerIndex": 1,
      "explanation": "After the corners, we shift one place inward or towards the center on each side. So, the next four elements to rotate are the 2nd element in the first row, the 2nd element in the last column, the second to last element in the last row, and the second to last element in the first column."
    },
    {
      "questionPrompt": "After we complete a layer, how should we update our pointers?",
      "choices": [
        {
          "choice": "Increment the left pointer and decrement the right pointer."
        },
        {
          "choice": "Decrement both the left and right pointers."
        },
        {
          "choice": "Increment both the left and right pointers."
        },
        {
          "choice": "Decrement the left pointer and increment the right pointer."
        }
      ],
      "answerIndex": 0,
      "explanation": "After we rotate a layer, we move inwards to the next layer. This involves incrementing the left pointer and decrementing the right pointer."
    },
    {
      "questionPrompt": "Considering the method of rotating each layer of the matrix, what would be the time complexity and space complexity of this operation?\n\n```python\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        l, r = 0, len(matrix) - 1\n\n        while l < r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                # save the topleft\n                topLeft = matrix[top][l + i]\n\n                # move bottom left into top left\n                matrix[top][l + i] = matrix[bottom - i][l]\n\n                # move bottom right into bottom left\n                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                # move top right into bottom right\n                matrix[bottom][r - i] = matrix[top + i][r]\n\n                # move top left into top right\n                matrix[top + i][r] = topLeft\n            r -= 1\n            l += 1\n```",
      "choices": [
        {
          "choice": "Time complexity: O(1)\nSpace complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n)\nSpace complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n^2)\nSpace complexity: O(1)"
        }
      ],
      "answerIndex": 2,
      "explanation": "The time complexity of the rotation operation is O(n^2). This is because, for each layer of the matrix, we perform a constant amount of work for each element, and there are n^2 total elements. The space complexity is O(1) because we perform the rotation in-place without allocating any additional significant space. The only extra space we use is a couple of variables to keep track of the current position and temporarily hold an element during the rotation."
    }
  ],
  "totalRatings": {
    "dislikes": 3,
    "likes": 35
  },
  "totalSubmissions": 639
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a4"
  },
  "id": "spiral-matrix",
  "name": "Spiral Matrix",
  "video": "BJnMZNwUk1M",
  "free": true,
  "pattern": "Math & Geometry",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven an `m x n` `matrix`, return *all elements of the* `matrix` *in spiral order*.\n\n**Example 1:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d23c7df9-a6dd-4b27-1b10-716af9df2c00/public)\n\n```\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\n```\n\n**Example 2:**\n\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7a94bac6-b2a5-4487-77b0-8313eb6e0900/public)\n\n```\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n```\n\n**Constraints:**\n\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= m, n <= 10`\n- `100 <= matrix[i][j] <= 100`\n",
  "questions": [
    {
      "questionPrompt": "What is the correct order of traversal to achieve a spiral order in a matrix?",
      "choices": [
        {
          "choice": "Top row from left to right, rightmost column from top to bottom, bottom row from right to left, leftmost column from bottom to top."
        },
        {
          "choice": "Top row from right to left, rightmost column from bottom to top, bottom row from left to right, leftmost column from top to bottom."
        }
      ],
      "answerIndex": 0,
      "explanation": "To achieve a spiral order in a matrix, we start by traversing the top row from left to right, then the rightmost column from top to bottom, then the bottom row from right to left, and finally the leftmost column from bottom to top. This completes one cycle of spiral traversal."
    },
    {
      "questionPrompt": "After completing one cycle of spiral traversal in the matrix, what should be the next step?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/cb1d1f77-711b-4fa0-e81f-fd5dfc35b700/public)",
      "choices": [
        {
          "choice": "Repeat the same cycle on the remaining submatrix."
        },
        {
          "choice": "Reverse the cycle on the remaining submatrix."
        },
        {
          "choice": "Transpose the remaining submatrix and then repeat the same cycle."
        }
      ],
      "answerIndex": 0,
      "explanation": "After completing one cycle of spiral traversal, the remaining submatrix will be smaller, but we should still traverse it in the same order: top row, rightmost column, bottom row, leftmost column."
    },
    {
      "questionPrompt": "To traverse an `m x n` matrix in a spiral order, how many pointers do we need and what do they represent?",
      "choices": [
        {
          "choice": "3 pointers - one for row, one for column, and one for diagonal traversal."
        },
        {
          "choice": "4 pointers - one for each of top, right, bottom, and left boundaries of the current submatrix."
        },
        {
          "choice": "5 pointers - one for each of top, right, bottom, left boundaries and one for the center of the matrix."
        }
      ],
      "answerIndex": 1,
      "explanation": "To traverse a 2D matrix in a spiral order, we need 4 pointers to keep track of the boundaries of the current submatrix we are traversing. These boundaries are top, right, bottom, and left. As we traverse, we progressively move the boundaries inward."
    },
    {
      "questionPrompt": "Given the Python code below for traversing a matrix in spiral order, what will be a potential issue when running this code on a non-square matrix? For example, consider what the output would be for `matrix = [[1, 2, 3]]`.\n\n```python\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        left, right = 0, len(matrix[0])\n        top, bottom = 0, len(matrix)\n\n        # while pointers have not met\n        while left < right and top < bottom:\n            # get every val in the top row\n            for i in range(left, right):\n                res.append(matrix[top][i])\n            top += 1\n            # get every val in the right col\n            for i in range(top, bottom):\n                res.append(matrix[i][right - 1])\n            right -= 1\n\n            # get every val in the bottom row\n            for i in range(right - 1, left - 1, -1):\n                res.append(matrix[bottom - 1][i])\n            bottom -= 1\n            # get every val in the left col\n            for i in range(bottom - 1, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n        return res\n```",
      "choices": [
        {
          "choice": "The code will fail to traverse the entire matrix."
        },
        {
          "choice": "The code will traverse the last submatrix multiple times."
        }
      ],
      "answerIndex": 1,
      "explanation": "The problem with this code is that it does not consider the case where the last submatrix is not square. If the last remaining part of the matrix is not square, the code will traverse the last submatrix multiple times. This is because there's no check to stop the bottom row and left column from being traversed again after the right column has been traversed and reduced. In the above example, the output would be [1, 2, 3, 2, 1], instead of [1, 2, 3] which is the expected result."
    },
    {
      "questionPrompt": "Consider the below code snippet. It returns the spiral order of elements in the given matrix without duplicating elements. What is its time and space complexity? Assume we include the output as additional space.\n\n```python\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        left, right = 0, len(matrix[0])\n        top, bottom = 0, len(matrix)\n\n        # while pointers have not met\n        while left < right and top < bottom:\n            # get every val in the top row\n            for i in range(left, right):\n                res.append(matrix[top][i])\n            top += 1\n            # get every val in the right col\n            for i in range(top, bottom):\n                res.append(matrix[i][right - 1])\n            right -= 1\n\n            if not (left < right and top < bottom):\n                # Pointers have met, so the spiral is complete\n                break\n\n            # get every val in the bottom row\n            for i in range(right - 1, left - 1, -1):\n                res.append(matrix[bottom - 1][i])\n            bottom -= 1\n            # get every val in the left col\n            for i in range(bottom - 1, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n        return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(m*n)\nSpace complexity: O(m*n)"
        },
        {
          "choice": "Time complexity: O(m^2)\nSpace complexity: O(n^2)"
        },
        {
          "choice": "Time complexity: O(m+n)\nSpace complexity: O(m+n)"
        }
      ],
      "answerIndex": 0,
      "explanation": "The time complexity of this function is O(m*n), where m is the number of rows and n is the number of columns in the input matrix. This is because each element is visited and processed exactly once. The space complexity is also O(m*n), because in the worst case, if all elements are stored in the output list, it will contain m*n elements."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 38
  },
  "totalSubmissions": 636
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a5"
  },
  "id": "insert-interval",
  "name": "Insert Interval",
  "video": "A8NUOmlwOlM",
  "free": true,
  "pattern": "Intervals",
  "difficulty": "Medium",
  "leetcodePrompt": "\nYou are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn `intervals` *after the insertion*.\n\n**Example 1:**\n\n```markdown\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\n```\n\n**Example 2:**\n\n```markdown\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n```\n\n**Constraints:**\n\n- `0 <= intervals.length <= 10^4`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 10^5`\n- `intervals` is sorted by `starti` in **ascending** order.\n- `newInterval.length == 2`\n- `0 <= start <= end <= 10^5`\n",
  "questions": [
    {
      "questionPrompt": "Is it possible that the `newInterval` overlaps with more than one interval in the list?",
      "choices": [
        {
          "choice": "Yes"
        },
        {
          "choice": "No"
        }
      ],
      "answerIndex": 0,
      "explanation": "Yes, it's possible. The `newInterval` might overlap with multiple intervals in the list if its start time is earlier than the end of one interval and its end time is later than the start of another."
    },
    {
      "questionPrompt": "As we iterate through the list of intervals, how do we know if the `newInterval` does not overlap with any of the intervals in the remaining portion of the list? (i.e. it does not overlap with the current interval or any subsequent intervals)\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1f41ea61-3124-453d-7545-b5d5168de700/public)",
      "choices": [
        {
          "choice": "If the end of newInterval is less than the start time of the current interval."
        },
        {
          "choice": "If the start of newInterval is greater than the end time of the current interval."
        },
        {
          "choice": "Both A and B"
        },
        {
          "choice": "None of the above"
        }
      ],
      "answerIndex": 0,
      "explanation": "If the end of newInterval is less than the start time of the current interval, newInterval does not overlap with the current interval or any subsequent intervals because the list is sorted in ascending order by start times."
    },
    {
      "questionPrompt": "How do we know if the `newInterval` is entirely to the right of the current interval?",
      "choices": [
        {
          "choice": "If the start of newInterval is greater than the end of the current interval."
        },
        {
          "choice": "If the end of newInterval is less than the start of the current interval."
        },
        {
          "choice": "Both A and B"
        },
        {
          "choice": "None of the above"
        }
      ],
      "answerIndex": 0,
      "explanation": "If the start of newInterval is greater than the end of the current interval, newInterval is entirely to the right of the current interval."
    },
    {
      "questionPrompt": "If the `newInterval` is not entirely to the left, nor entirely to the right of the current interval, does that guarantee it overlaps with the current interval?",
      "choices": [
        {
          "choice": "No"
        },
        {
          "choice": "Yes"
        },
        {
          "choice": "Cannot be determined"
        }
      ],
      "answerIndex": 1,
      "explanation": "By definition, the newInterval must be overlapping with the current interval. Otherwise, it would be on the left or on the right of the current interval. (Proof by contradiction)."
    },
    {
      "questionPrompt": "After merging two intervals, what should be the new interval that we attempt to merge with the remaining overlapping intervals?",
      "choices": [
        {
          "choice": "The original newInterval"
        },
        {
          "choice": "intervals[i] BEFORE it was merged with newInterval"
        },
        {
          "choice": "intervals[i] AFTER it was merged with newInterval"
        }
      ],
      "answerIndex": 2,
      "explanation": "After merging two intervals, the new interval to attempt merging with the remaining intervals should have the earliest start time and the latest end time among the merged intervals. This ensures that the new interval covers all the values in the merged intervals."
    },
    {
      "questionPrompt": "To summarize, the below code will optimally solve this problem. What is the overall time complexity and the space complexity? Assume the output counts as additional space.\n\n```python\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                # newInterval doesn't overlap with remaining list\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                # newInterval is entirely to right of intervals[i]\n                res.append(intervals[i])\n            else:\n                # newInterval overlaps with current interval\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n        res.append(newInterval)\n        return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(1), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        }
      ],
      "answerIndex": 2,
      "explanation": "The time complexity is O(n) because we may need to check each interval once, and the space complexity is O(n) because in the worst case, if `newInterval` doesn't overlap with any intervals, the output will be a list with the same length as the input plus one additional interval (`newInterval`). We also need some additional space to store the merged intervals during the process, but this does not change the overall linear space complexity."
    }
  ],
  "totalRatings": {
    "dislikes": 1,
    "likes": 33
  },
  "totalSubmissions": 574
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a6"
  },
  "id": "merge-intervals",
  "name": "Merge Intervals",
  "video": "44H3cEC2fFM",
  "free": true,
  "pattern": "Intervals",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.\n\n**Example 1:**\n\n```\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n```\n\n**Example 2:**\n\n```\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\n```\n\n**Constraints:**\n\n- `1 <= intervals.length <= 10^4`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 10^4`\n",
  "questions": [
    {
      "questionPrompt": "Given an unsorted list of intervals, in what order should we arrange the intervals to simplify the process of merging overlaps?",
      "choices": [
        {
          "choice": "Sort by the start times of each interval"
        },
        {
          "choice": "Sort by the lengths of each interval"
        },
        {
          "choice": "The order doesn't matter"
        }
      ],
      "answerIndex": 0,
      "explanation": "Sorting the intervals by their start times helps simplify the process of detecting and merging overlaps. Any overlapping intervals will be adjacent to each other in the sorted list."
    },
    {
      "questionPrompt": "After sorting the intervals by start times, how can we determine if two intervals overlap?",
      "choices": [
        {
          "choice": "End of the first interval > Start of the second interval"
        },
        {
          "choice": "End of the first interval ≥ Start of the second interval"
        }
      ],
      "answerIndex": 1,
      "explanation": "If the intervals are sorted by their start times, then the end of the current interval being greater than or equal to the start of the next interval means they overlap."
    },
    {
      "questionPrompt": "What should you do when two intervals overlap?",
      "choices": [
        {
          "choice": "Discard one interval and keep the other."
        },
        {
          "choice": "Merge the two intervals into a single interval."
        },
        {
          "choice": "Split the intervals into smaller non-overlapping intervals."
        }
      ],
      "answerIndex": 1,
      "explanation": "If two intervals overlap, they represent a continuous range of values and should be merged into a single interval."
    },
    {
      "questionPrompt": "*After* sorting the intervals, what is the time complexity of the step where we *only* merge overlapping intervals?",
      "choices": [
        {
          "choice": "O(n)"
        },
        {
          "choice": "O(n log n)"
        },
        {
          "choice": "O(n^2)"
        }
      ],
      "answerIndex": 0,
      "explanation": "Once the intervals are sorted, you can iterate over them once to merge overlapping intervals. Therefore, the time complexity of this step is O(n)."
    },
    {
      "questionPrompt": "What is the overall time and space complexity of the optimal solution considering the sorting process and the merging process?\n\n```python\nclass Solution:\n  def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n    intervals.sort()\n    output = [intervals[0]]\n\n    for start, end in intervals[1:]:\n      prevEnd = output[-1][1]\n\n      if prevEnd >= start:\n        output[-1][1] = max(prevEnd, end) # merge\n      else:\n        output.append([start, end])\n\n    return output\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The overall time complexity of the solution is determined by the most time-consuming step. Sorting the intervals has a time complexity of O(n log n), while merging has a time complexity of O(n). Therefore, the overall time complexity is O(n log n). The space complexity is O(n) because in the worst-case scenario, if no intervals overlap, the output will be a list with the same length as the input. We also use some additional space for sorting the intervals, but this does not change the overall linear space complexity."
    }
  ],
  "totalRatings": {
    "dislikes": 0,
    "likes": 55
  },
  "totalSubmissions": 642
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a7"
  },
  "id": "non-overlapping-intervals",
  "name": "Non Overlapping Intervals",
  "video": "nONCGxWoUfM",
  "free": true,
  "pattern": "Intervals",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return *the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping*.\n\n**Example 1:**\n\n```\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n```\n\n**Example 2:**\n\n```\nInput: intervals = [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n```\n\n**Example 3:**\n\n```\nInput: intervals = [[1,2],[2,3]]\nOutput: 0\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.\n```\n\n**Constraints:**\n\n- `1 <= intervals.length <= 10^5`\n- `intervals[i].length == 2`\n- `5 * 10^4 <= starti < endi <= 5 * 10^4`\n",
  "questions": [
    {
      "questionPrompt": "Are these two intervals overlapping? `[1,2]` and `[2,3]`",
      "choices": [
        {
          "choice": "Yes"
        },
        {
          "choice": "No"
        },
        {
          "choice": "Can't determine"
        }
      ],
      "answerIndex": 1,
      "explanation": "In the context of this problem the two intervals are not overlapping (See example 3). Yes, I think it's strange that LC changes the definition of 'overlapping' based on the problem, but example 3 tries to make this clear."
    },
    {
      "questionPrompt": "Since overlapping intervals will be adjacent, which operation can simplify the process of finding overlaps?",
      "choices": [
        {
          "choice": "Sorting the intervals by the start times."
        },
        {
          "choice": "Reversing the order of the intervals."
        },
        {
          "choice": "Shuffling the intervals randomly."
        }
      ],
      "answerIndex": 0,
      "explanation": "Sorting the intervals by their start times helps in aligning the intervals in increasing order. It simplifies the process of finding overlapping intervals because once the list is sorted, we can simply compare each interval with its next one to check for overlaps."
    },
    {
      "questionPrompt": "As we iterate through the sorted intervals, how do we know if the current interval does *not* overlap with the previous interval?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4ba3ef8f-eb81-465b-3c7b-741329d31a00/public)",
      "choices": [
        {
          "choice": "If the end time of the current interval is less than the start time of the previous interval."
        },
        {
          "choice": "If the start time of the current interval is greater than or equal to the end time of the previous interval."
        },
        {
          "choice": "If the end time of the current interval is equal to the start time of the previous interval."
        }
      ],
      "answerIndex": 1,
      "explanation": "If the start time of the current interval is greater than or equal to the end time of the previous interval, it means there is no overlap. The current interval starts only after the previous one ends."
    },
    {
      "questionPrompt": "When two intervals overlap, which should we remove?\n![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/daf9f6f4-c822-43cd-6d08-63db0a4a4b00/public)",
      "choices": [
        {
          "choice": "The interval with the earliest start time."
        },
        {
          "choice": "The interval with the latest end time."
        },
        {
          "choice": "The smallest interval."
        }
      ],
      "answerIndex": 1,
      "explanation": "The optimal strategy is to always remove the interval with the latest end time among the overlapping intervals. This is because it leaves more room for the rest of the intervals to fit in without overlapping."
    },
    {
      "questionPrompt": "To summarize, the below code will optimally solve this problem. What is the overall time and space complexity?\n```python\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        res = 0\n        prevEnd = intervals[0][1]\n        for start, end in intervals[1:]:\n            if start >= prevEnd:\n                # Curr interval is to the right of prev\n                prevEnd = end\n            else:\n                # Intervals overlap, keep interval with smaller end\n                res += 1\n                prevEnd = min(end, prevEnd)\n        return res\n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(1)"
        }
      ],
      "answerIndex": 1,
      "explanation": "The time complexity of the optimal solution is O(n log n) because you have to sort the intervals first, which takes O(n log n) time. Then, you iterate over the sorted intervals once, which takes O(n) time. The space complexity is O(n) because in the worst-case scenario, you store all n intervals in the input array. The additional space used for sorting does not change the overall linear space complexity."
    }
  ],
  "totalRatings": {
    "dislikes": 3,
    "likes": 31
  },
  "totalSubmissions": 587
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a8"
  },
  "id": "meeting-rooms",
  "name": "Meeting Rooms",
  "video": "PaJxqZVPhbg",
  "free": true,
  "pattern": "Intervals",
  "difficulty": "Easy",
  "leetcodePrompt": "\nGiven an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, determine if a person could attend all meetings.\n\nNote: `(0,8),(8,10)` is not a conflict at `8`\n\n**Example1**\n\n```\nInput: intervals = [(0,30),(5,10),(15,20)]\nOutput: false\nExplanation:\n(0,30), (5,10) and (0,30),(15,20) will conflict\n```\n\n**Example2**\n\n```\nInput: intervals = [(5,8),(9,15)]\nOutput: true\nExplanation:\nTwo times will not conflict\n```\n\n\n**Constraints:**\n* `0 <= intervals.length <= 10^4` \n* `intervals[i].length == 2`\n* `0 <= intervals[i][0] < intervals[i][1] <= 10^6`\n",
  "questions": [
    {
      "questionPrompt": "Given an unsorted list of intervals, what is the first step we should take to determine if a person could attend all meetings?",
      "choices": [
        {
          "choice": "Sort by the start times of each interval"
        },
        {
          "choice": "Sort by the length of each interval"
        }
      ],
      "answerIndex": 0,
      "explanation": "Sorting the intervals by their start times will help us to check the conflicts easily. The intervals will be arranged in a way that their start times are in ascending order."
    },
    {
      "questionPrompt": "As we iterate through the sorted intervals, how do we know if an adjacent pair of intervals is overlapping?",
      "choices": [
        {
          "choice": "If start of the first interval < end of the second interval"
        },
        {
          "choice": "If end of the first interval ≥ start of the second interval"
        },
        {
          "choice": "If end of the first interval > start of the second interval"
        }
      ],
      "answerIndex": 2,
      "explanation": "If the intervals are sorted by their start times, then the end of the current interval being greater than the start of the next interval means they overlap and hence create a conflict in the meeting schedule. The reason ≥ doesn’t necessarily work is because a meeting could end as the next one begins, and it would be possible to attend both meetings."
    },
    {
      "questionPrompt": "What should you do when two intervals overlap?",
      "choices": [
        {
          "choice": "Combine both intervals and consider it as one."
        },
        {
          "choice": "Do nothing, proceed to the next pair."
        },
        {
          "choice": "Return false, indicating a conflict in the schedule."
        }
      ],
      "answerIndex": 2,
      "explanation": "When two intervals overlap, it signifies a conflict in the meeting schedule. Since our aim is to check if a person could attend all meetings, once a conflict is found, we can return false."
    },
    {
      "questionPrompt": "What is the overall time and space complexity of the optimal solution for this problem?\n\n```python\nclass Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        intervals.sort() # Sort by start times\n\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i-1][1]: # Check for overlap\n                return False # Conflict found\n\n        return True # No conflict found\n```\n",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(1)"
        }
      ],
      "answerIndex": 2,
      "explanation": "The overall time complexity of the solution is determined by the most time-consuming step. Sorting the intervals has a time complexity of O(n log n). After sorting, we iterate over the intervals once which has a time complexity of O(n). Therefore, the overall time complexity is O(n log n). The space complexity is O(1) because we do not use any additional data structures whose size depends on the input. Sorting the array in-place ensures that we do not use any extra space."
    }
  ],
  "totalRatings": {
    "dislikes": 0,
    "likes": 89
  },
  "totalSubmissions": 1075
},
{
  "_id": {
    "$oid": "65994f653cd5ace93a8917a9"
  },
  "id": "meeting-rooms-ii",
  "name": "Meeting Rooms II",
  "video": "FdzJmTCVyJU",
  "free": true,
  "pattern": "Intervals",
  "difficulty": "Medium",
  "leetcodePrompt": "\nGiven an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, find the minimum number of conference rooms required.\n\n\n**Example1**\n\n```\nInput: intervals = [(0,30),(5,10),(15,20)]\nOutput: 2\nExplanation:\nWe need two meeting rooms\nroom1: (0,30)\nroom2: (5,10),(15,20)\n```\n\n**Example2**\n\n```\nInput: intervals = [(2,7)]\nOutput: 1\nExplanation:\nOnly need one meeting room\n```\n\n**Constraints:**\n* `0 <= intervals.length <= 10^4` \n* `intervals[i].length == 2`\n* `0 <= intervals[i][0] < intervals[i][1] <= 10^6`\n",
  "questions": [
    {
      "questionPrompt": "In the context of this problem, what’s an equivalent way of thinking about the minimum number of conference rooms needed?",
      "choices": [
        {
          "choice": "The total number of meetings"
        },
        {
          "choice": "The maximum number of overlapping intervals at any given point in time"
        },
        {
          "choice": "The minimum number of overlapping intervals at any given point in time"
        }
      ],
      "answerIndex": 1,
      "explanation": "The minimum number of meeting rooms is equivalent to finding the maximum number of overlapping intervals at any given point in time. This is because each overlapping interval would require a separate room."
    },
    {
      "questionPrompt": "We can try to iterate through the intervals to count how many meetings are going on at any given point in time. What should be our first step?",
      "choices": [
        {
          "choice": "By sorting the start and end times in separate arrays"
        },
        {
          "choice": "By sorting the intervals by start time"
        },
        {
          "choice": "By sorting the intervals by length"
        }
      ],
      "answerIndex": 0,
      "explanation": "Sorting the start and end times separately allows us to efficiently track when meetings start and end. This makes it easy to count the number of meetings at any given time."
    },
    {
      "questionPrompt": "As we iterate through these sorted arrays, `start` and `end`, how do we know if a new meeting has started?",
      "choices": [
        {
          "choice": "start[s] < end[e]"
        },
        {
          "choice": "start[s] == end[e]"
        },
        {
          "choice": "start[s] > end[e]"
        }
      ],
      "answerIndex": 0,
      "explanation": "If the start time of the next meeting (start[s]) is less than the end time of the current earliest ending meeting (end[e]), it indicates a new meeting has started before a current one has ended."
    },
    {
      "questionPrompt": "As we iterate through these sorted arrays, `start` and `end`, how do we know if a meeting has ended?",
      "choices": [
        {
          "choice": "start[s] < end[e]"
        },
        {
          "choice": "start[s] == end[e]"
        },
        {
          "choice": "end[e] <= start[s]"
        }
      ],
      "answerIndex": 2,
      "explanation": "If the end time of the current earliest ending meeting (end[e]) is less than or equal to the start time of the next meeting (start[s]), it indicates that a current meeting has ended. We don’t necessarily know the start time of this meeting, but we can still keep track of the number of ongoing meetings which is our goal."
    },
    {
      "questionPrompt": "To summarize, the below code will solve this problem optimally. What is the overall time and space complexity?\n```python\nclass Solution:\n    def minMeetingRooms(self, intervals):\n        # Separate out the start and the end timings and sort them individually.\n        start = sorted([i[0] for i in intervals])\n        end = sorted(i[1] for i in intervals)\n\n        s = e = 0\n        used_rooms, res = 0, 0\n        while s < len(intervals):\n            if start[s] < end[e]:\n                # A new meeting is starting\n                used_rooms += 1\n                s += 1\n            else:\n                # A current meeting is ending\n                used_rooms -= 1\n                e += 1\n            res = max(res, used_rooms)\n\n        return res \n```",
      "choices": [
        {
          "choice": "Time complexity: O(n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n log n), Space complexity: O(n)"
        },
        {
          "choice": "Time complexity: O(n^2), Space complexity: O(n)"
        }
      ],
      "answerIndex": 1,
      "explanation": "Sorting the start and end times has a time complexity of O(n log n). The subsequent iteration over the start times doesn't change the time complexity, so the overall time complexity remains O(n log n). The space complexity is O(n) because we store the start times and end times of all meetings separately."
    }
  ],
  "totalRatings": {
    "dislikes": 2,
    "likes": 44
  },
  "totalSubmissions": 698
}]